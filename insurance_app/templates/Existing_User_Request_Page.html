<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/static/css/logo.css">
    <script defer src="/static/js/logo.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Existing User request Page</title>
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/health_history.css">
    <link rel="stylesheet" href="../css/members.css">
    <link rel="stylesheet" href="../css/top_bar.css">
    <style>
        .loader-bar { display:flex; gap:.5rem; align-items:center; }
        .loader-bar input { max-width: 240px; }
        /* Right-align header actions (Logout, Home) and keep them adjacent */
        .top-bar { display: flex; align-items: center; gap: 12px; }
        .top-bar .user-info { margin-right: auto; }
        .top-bar .right-actions { display: flex; gap: 8px; align-items: center; }
        /* Supervisor meta styles */
        .supervisor-meta .loader-bar label { min-width: 160px; }
        #sup-status-input { max-width: 280px; }
        .comment-box { border:1px solid #ccc; padding:8px; min-height:40px; background:#fff; }
        .form-actions { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .last-modified-inline { margin-left: auto; }
    </style>
</head>
<body>
    <header class="top-bar">
    <link rel="stylesheet" href="/static/css/logo.css">
    <script defer src="/static/js/logo.js"></script>
        <div class="user-info">
            Logged in as: <span id="logged-in-user" class="user-id"></span>
        </div>
        <div class="right-actions">
            <button id="logout-btn" class="btn btn-logout">Logout</button>
            <button id="btn-home" class="btn">Home</button>
        </div>
    </header>
    <div class="container">
        <header class="page-header">
    <link rel="stylesheet" href="/static/css/logo.css">
    <script defer src="/static/js/logo.js"></script>
            <h1>Existing User request Page</h1>
        </header>
        <form id="insurance-form" novalidate>

        <div class="loader-bar">
            <label for="load-unique-id"><strong>Unique ID</strong></label>
            <input id="load-unique-id" type="text" placeholder="Enter Unique ID" />
            <button id="btn-load" class="btn btn-secondary" type="button">Load</button>
        </div>

        <p id="load-status" class="muted"></p>

        <!-- Supervisor status & comments (non-collapsible) -->
        <section id="supervisor-meta" class="section supervisor-meta" style="display:none;">
            <div class="form-group" style="margin-top:8px;">
                <div><strong>Status</strong></div>
                <div id="sup-summary" class="comment-box" role="textbox" aria-readonly="true" style="white-space:normal; font-family: inherit; font-size: inherit; line-height:1.2; min-height: 48px; padding:0; margin:0;"></div>
            </div>
        </section>

        <!-- <p>Edit existing proposal details. After loading by Unique ID, you can modify and resubmit.</p> -->

        <div id="primary-contact-placeholder" class="section"></div>
        <div id="Health-History-placeholder" class="section"></div>
        <div id="members-covered-placeholder" class="section"></div>
        <div id="cover-cost-placeholder" class="section"></div>
        <div id="existing-coverage-placeholder" class="section"></div>
        <div id="claims-service-placeholder" class="section"></div>
        <div id="Finance-Documentation-placeholder" class="section"></div>
        <div id="comments-noted-placeholder" class="section"></div>

        <div class="form-actions">
            <button type="submit" id="submit-btn" class="btn">Submit</button>
            <button type="button" id="preview-btn" class="btn">Preview</button>
            <button type="reset" id="reset-btn" class="btn btn-secondary">Reset</button>
            <div id="last-modified-container" class="last-modified-inline"></div>
        </div>
        </form>
    </div>

    <script src="../js/calculations.js"></script>
    <script src="../js/validation.js"></script>
    <script src="../js/member_management.js"></script>
    <script src="../js/disease_details.js"></script>
    <script src="../js/comments_noted.js"></script>

    <!-- Prefill helper must load before script.js to register functions -->
    <script src="../js/existing_prefill.js"></script>
    <script src="../js/script.js" defer></script>
    <script src="../js/data_fetch.js" defer></script>

    <script>
        // Utility function for timestamp formatting
        function formatTimestampForDisplay(timestampStr) {
            if (!timestampStr) return '—';
            
            try {
                let dt = null;
                
                // Try ISO format first
                try {
                    dt = new Date(timestampStr.replace('Z', ''));
                    if (isNaN(dt.getTime())) dt = null;
                } catch (e) {}
                
                // Try application format: YYYY-MM-DD_HH-MM-SS
                if (!dt && timestampStr.includes('_')) {
                    try {
                        const parts = timestampStr.split('_');
                        if (parts.length === 2) {
                            const datePart = parts[0];
                            const timePart = parts[1].replace(/-/g, ':');
                            dt = new Date(`${datePart}T${timePart}`);
                        }
                    } catch (e) {}
                }
                
                if (dt) {
                    // Convert to IST timezone
                    return dt.toLocaleString('en-IN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true,
                        timeZone: 'Asia/Kolkata'
                    });
                }
                
                return timestampStr; // Return original if parsing fails
            } catch (e) {
                console.warn('Error formatting timestamp:', e);
                return timestampStr;
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const loggedInUserEl = document.getElementById('logged-in-user');
            const logoutBtn = document.getElementById('logout-btn');
            const homeBtn = document.getElementById('btn-home');
            const statusEl = document.getElementById('load-status');
            const loadBtn = document.getElementById('btn-load');
            const idInput = document.getElementById('load-unique-id');
            const form = document.getElementById('insurance-form');
            const submitBtn = document.getElementById('submit-btn');
            const previewBtn = document.getElementById('preview-btn');
            const resetBtn = document.getElementById('reset-btn');

            function setActionButtonsEnabled(enabled) {
                if (submitBtn) submitBtn.disabled = !enabled;
                if (previewBtn) previewBtn.disabled = !enabled;
                if (resetBtn) resetBtn.disabled = !enabled;
            }

            const userId = localStorage.getItem('loggedInUserId');
            if (userId) {
                loggedInUserEl.textContent = userId;
            } else {
                window.location.href = 'Main_login.html';
            }

            logoutBtn.addEventListener('click', function() {
                localStorage.removeItem('loggedInUserId');
                window.location.href = 'Main_login.html';
            });

            if (homeBtn) {
                homeBtn.addEventListener('click', function(){
                    window.location.href = '/html/Health_Insurance_Proposal_Request.html';
                });
            }

            // Deep reset: clears form fields and all dynamic state (members, comments, mirrors)
            function hardResetForm() {
                try {
                    // 1) Clear dynamic storage/state
                    localStorage.removeItem('members');
                    localStorage.removeItem('formSummary');
                    localStorage.removeItem('submissionData');
                    localStorage.removeItem('plans');
                    localStorage.removeItem('editMemberId');
                    localStorage.removeItem('comments_noted'); // mirror used by Preview
                    sessionStorage.removeItem('currentUniqueId');

                    // 2) Reset all form controls to empty/unchecked/default
                    if (form) {
                        // First call HTML reset to clear user-entered values
                        form.reset();
                        // Then force-clear any remaining values and selects
                        const ctrls = form.querySelectorAll('input, select, textarea');
                        ctrls.forEach(el => {
                            const tag = (el.tagName || '').toLowerCase();
                            const type = (el.type || '').toLowerCase();
                            if (tag === 'input') {
                                if (type === 'checkbox' || type === 'radio') {
                                    el.checked = false;
                                } else {
                                    el.value = '';
                                }
                            } else if (tag === 'select') {
                                el.selectedIndex = 0;
                            } else if (tag === 'textarea') {
                                el.value = '';
                            }
                        });
                    }

                    // 3) Clear members UI if present
                    try {
                        const membersList = document.getElementById('members-list');
                        if (membersList) membersList.innerHTML = '';
                        const summaryContent = document.getElementById('summary-content');
                        if (summaryContent) summaryContent.innerHTML = '<p class="placeholder-text">Hover over a member to see their details.</p>';
                        if (window.loadMembersGlobal) window.loadMembersGlobal();
                        if (window.updatePeopleCounter) window.updatePeopleCounter();
                    } catch(e) { /* ignore */ }

                    // 4) Clear comments UI and local mirror
                    try {
                        if (typeof window.clearCommentsSession === 'function') {
                            window.clearCommentsSession();
                        } else {
                            // Fallback: clear table elements if present
                            const tb = document.getElementById('comments-tbody');
                            if (tb) tb.innerHTML = '';
                            const tbl = document.getElementById('comments-table');
                            if (tbl) tbl.style.display = 'none';
                            const noMsg = document.getElementById('no-comments-message');
                            if (noMsg) noMsg.style.display = 'block';
                        }
                    } catch(e) { /* ignore */ }

                    // 5) Clear status/info displays
                    statusEl.textContent = '';
                    const supSummary = document.getElementById('sup-summary');
                    if (supSummary) supSummary.textContent = '';
                    const lastMod = document.getElementById('last-modified-footer');
                    if (lastMod) lastMod.style.display = 'none';

                    // 6) Re-enable action buttons
                    setActionButtonsEnabled(true);
                } catch (e) {
                    console.warn('Hard reset encountered an issue:', e);
                }
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', function(ev){
                    ev.preventDefault(); // override default so we can deep-clear
                    hardResetForm();
                });
            }

            function attachOrCreateLastModifiedFooter() {
                const host = document.getElementById('last-modified-container');
                if (!host) return;
                let footer = document.getElementById('last-modified-footer');
                if (!footer) {
                    // Create a footer element compatible with comments_noted.js expectations
                    footer = document.createElement('div');
                    footer.id = 'last-modified-footer';
                    footer.className = 'last-modified-footer';
                    footer.style.display = 'none';
                    footer.innerHTML = 'Last Modified by <span id="last-modified-by">—</span> on <span id="last-modified-date">—</span>';
                } else if (footer.parentElement !== host) {
                    // Move existing footer into host
                    footer.parentElement.removeChild(footer);
                }
                host.appendChild(footer);
            }

            function updateMainLastModified(data) {
                attachOrCreateLastModifiedFooter();
                const footer = document.getElementById('last-modified-footer');
                const lastModifiedBy = document.getElementById('last-modified-by');
                const lastModifiedDate = document.getElementById('last-modified-date');
                if (!footer || !lastModifiedBy || !lastModifiedDate) return;

                // Try to get the most recent modification info from various sources
                let modifiedBy = '—';
                let modifiedAt = null;

                // Priority order: Check all possible modification timestamps and use the latest one
                const timestampSources = [
                    { by: data.application_modified_by, at: data.application_modified_at, source: 'final' },
                    { by: data.underwriter_modified_by, at: data.underwriter_modified_at, source: 'underwriter' },
                    { by: data.supervisor_modified_by, at: data.supervisor_modified_at, source: 'supervisor' },
                    { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at, source: 'policy' },
                    { by: data.close_status_modified_by, at: data.close_status_modified_at, source: 'application' },
                    { by: data.first_created_by, at: data.first_created_at, source: 'created' }
                ];
                
                // Filter out entries without both by and at values, then sort by timestamp (latest first)
                const validTimestamps = timestampSources
                    .filter(ts => ts.by && ts.at)
                    .sort((a, b) => {
                        try {
                            const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                            const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                            return dateB - dateA; // Latest first
                        } catch (e) {
                            return 0;
                        }
                    });
                
                if (validTimestamps.length > 0) {
                    const latest = validTimestamps[0];
                    modifiedBy = latest.by;
                    modifiedAt = latest.at;
                    console.log('Using latest timestamp from:', latest.source, 'by:', latest.by, 'at:', latest.at);
                }

                // Format the timestamp using improved formatting
                let formattedDate = '—';
                if (modifiedAt) {
                    formattedDate = formatTimestampForDisplay(modifiedAt);
                }

                // Update the footer
                lastModifiedBy.textContent = modifiedBy;
                lastModifiedDate.textContent = formattedDate;
                footer.style.display = 'block';
            }

            async function loadById(uniqueId) {
                const uid = (uniqueId || '').trim();
                statusEl.textContent = '';
                if (!uid) { statusEl.textContent = 'Please enter Unique ID.'; return; }
                try {
                    // Use the API that returns the full submission row (includes final_* fields)
                    const resp = await fetch(`/api/agent/submission/${encodeURIComponent(uid)}`);
                    if (!resp.ok) { statusEl.textContent = 'Submission not found.'; return; }
                    const data = await resp.json();
                    // existing_prefill.js expects the raw form payload (what was originally saved in form_summary)
                    // The /api/agent/submission endpoint returns the full row; extract and parse form_summary for prefill
                    let formPayload = null;
                    try {
                        if (typeof data.form_summary === 'string') {
                            formPayload = JSON.parse(data.form_summary);
                        } else if (data.form_summary && typeof data.form_summary === 'object') {
                            formPayload = data.form_summary;
                        }
                    } catch (e) { formPayload = null; }
                    // Fallback 1: if form_summary missing, try legacy endpoint that returns raw form payload
                    if (!formPayload) {
                        try {
                            const legacy = await fetch(`/submission/${encodeURIComponent(uid)}`);
                            if (legacy.ok) {
                                formPayload = await legacy.json();
                            }
                        } catch (e) { /* ignore */ }
                    }
                    // Fallback 2: best-effort with full row
                    if (!formPayload) formPayload = data;
                    if (window.prefillExistingForm) {
                        await window.prefillExistingForm(formPayload);
                        statusEl.textContent = 'Data loaded. You can edit and save.';
                    } else {
                        statusEl.textContent = 'Prefill function not available.';
                    }

                    // Initialize Comments Noted for this UID
                    localStorage.setItem('currentUniqueId', uid);
                    if (window.initializeCommentsNoted) {
                        window.initializeCommentsNoted();
                    }
                    if (window.loadExistingComments) {
                        window.loadExistingComments(uid);
                    }

                    // Update main Last Modified display
                    updateMainLastModified(data);

                    // Show status section right away (Final_* from DB)
                    const supSection = document.getElementById('supervisor-meta');
                    const supSummary = document.getElementById('sup-summary');
                    if (supSection) supSection.style.display = '';
                    if (supSummary) supSummary.textContent = 'Loading status...';

                    // Render Final_* from primary submission payload
                    (function(){
                        if (!supSummary) return;
                        const statusDisp = (data.final_status && String(data.final_status).trim()) ? data.final_status : (data.supervisor_approval_status || 'Open');
                        const comments = (data.application_comments && String(data.application_comments).trim()) ? data.application_comments : 'No comments';
                        // Find the latest modifier from all possible sources
                        let tsStr = '—';
                        let by = '—';
                        
                        const timestampSources = [
                            { by: data.application_modified_by, at: data.application_modified_at, source: 'final' },
                            { by: data.underwriter_modified_by, at: data.underwriter_modified_at, source: 'underwriter' },
                            { by: data.supervisor_modified_by, at: data.supervisor_modified_at, source: 'supervisor' },
                            { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at, source: 'policy' },
                            { by: data.close_status_modified_by, at: data.close_status_modified_at, source: 'application' },
                            { by: data.agent, at: data.timestamp, source: 'submission' },
                            { by: data.first_created_by, at: data.first_created_at, source: 'created' }
                        ];
                        
                        // Filter out entries without both by and at values, then sort by timestamp (latest first)
                        const validTimestamps = timestampSources
                            .filter(ts => ts.by && ts.at)
                            .sort((a, b) => {
                                try {
                                    const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                                    const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                                    return dateB - dateA; // Latest first
                                } catch (e) {
                                    return 0;
                                }
                            });
                        
                        if (validTimestamps.length > 0) {
                            const latest = validTimestamps[0];
                            by = latest.by;
                            const rawAt = latest.at;
                            
                            // Parse the timestamp
                            if (rawAt) {
                                const isoTry = new Date(rawAt);
                                if (!isNaN(isoTry.getTime())) {
                                    tsStr = isoTry.toLocaleString();
                                } else if (typeof rawAt === 'string') {
                                    const parts = rawAt.split('_');
                                    if (parts.length === 2) {
                                        const datePart = parts[0];
                                        const timePart = parts[1].replace(/-/g, ':');
                                        const iso = `${datePart}T${timePart}`;
                                        const d = new Date(iso);
                                        if (!isNaN(d.getTime())) tsStr = d.toLocaleString();
                                    }
                                }
                            }
                        }
                        const summaryHtml = '<strong>Application Status:</strong> ' + statusDisp + '<br>' +
                                           '<strong>Comments:</strong> ' + comments + '<br>' +
                                           '<strong>Last Updated by:</strong> ' + by + ' <strong>Last Updated at:</strong> ' + tsStr;
                        supSummary.innerHTML = summaryHtml;
                        const norm = String(statusDisp || '').trim().toUpperCase();
                        const allowed = (norm === 'OPEN' || norm === 'SUP_REJECTED');
                        setActionButtonsEnabled(allowed);
                    })();

                    // If Final_* missing (older data), fall back to /submission/<uid>/meta
                    if (!data.final_status) {
                        try {
                            const metaResp = await fetch(`/submission/${encodeURIComponent(uid)}/meta`);
                            if (metaResp.ok) {
                                const meta = await metaResp.json();
                                if (supSummary) {
                                    const raw = (meta.supervisor_status || '').toString();
                                    const normalized = raw.trim().toUpperCase();
                                    const statusDisp = normalized === 'OPEN' ? 'Open' : (raw || 'Open');
                                    const comments = (meta.supervisor_comments && String(meta.supervisor_comments).trim()) ? meta.supervisor_comments : 'No comments';
                                    let tsStr = '—';
                                    if (meta.supervisor_modified_at) {
                                        tsStr = new Date(meta.supervisor_modified_at).toLocaleString();
                                    } else if (meta.first_created_at || meta.created_at) {
                                        const rawCreated = String(meta.first_created_at || meta.created_at);
                                        const parts = rawCreated.split('_');
                                        if (parts.length === 2) {
                                            const datePart = parts[0];
                                            const timePart = parts[1].replace(/-/g, ':');
                                            const iso = `${datePart}T${timePart}`;
                                            const d = new Date(iso);
                                            if (!isNaN(d.getTime())) tsStr = d.toLocaleString();
                                        } else {
                                            const d = new Date(rawCreated);
                                            if (!isNaN(d.getTime())) tsStr = d.toLocaleString();
                                        }
                                    }
                                    const by = meta.supervisor_modified_by || '—';
                                    const summaryHtml = '<strong>Application Status:</strong> ' + statusDisp + '<br>' +
                                                       '<strong>Comments:</strong> ' + comments + '<br>' +
                                                       '<strong>Last Updated by:</strong> ' + by + ' <strong>Last Updated at:</strong> ' + tsStr;
                                    supSummary.innerHTML = summaryHtml;
                                    const norm = String(statusDisp || '').trim().toUpperCase();
                                    const allowed = (norm === 'OPEN' || norm === 'SUP_REJECTED');
                                    setActionButtonsEnabled(allowed);
                                }
                            } else {
                                // Fallback to submission fields if meta not available
                                if (supSummary) {
                                    const raw = (data.supervisor_approval_status || '').toString();
                                    const normalized = raw.trim().toUpperCase();
                                    const statusDisp = normalized === 'OPEN' ? 'Open' : (raw || 'Open');
                                    const comments = (data.supervisor_comments && String(data.supervisor_comments).trim()) ? data.supervisor_comments : 'No comments';
                                    let tsStr = '—';
                                    const createdRaw = data.first_created_at || data.created_at || '';
                                    if (createdRaw) {
                                        const parts = String(createdRaw).split('_');
                                        if (parts.length === 2) {
                                            const datePart = parts[0];
                                            const timePart = parts[1].replace(/-/g, ':');
                                            const iso = `${datePart}T${timePart}`;
                                            const d = new Date(iso);
                                            if (!isNaN(d.getTime())) tsStr = d.toLocaleString();
                                        }
                                    }
                                    const by = data.supervisor_modified_by || '—';
                                    const summaryHtml = '<strong>Application Status:</strong> ' + statusDisp + '<br>' +
                                                           '<strong>Comments:</strong> ' + comments + '<br>' +
                                                           '<strong>Last Updated by:</strong> ' + by + ' <strong>Last Updated at:</strong> ' + tsStr;
                                    supSummary.innerHTML = summaryHtml;
                                    const norm = String(statusDisp || '').trim().toUpperCase();
                                    const allowed = (norm === 'OPEN' || norm === 'SUP_REJECTED');
                                    setActionButtonsEnabled(allowed);
                                }
                            }
                        } catch (e) {
                            // Non-fatal; keep form usable even if meta fails
                            console.warn('Failed to fetch supervisor meta', e);
                            const supSummary = document.getElementById('sup-summary');
                            if (supSummary) supSummary.textContent = 'Status unavailable.';
                        }
                    }
                } catch (e) {
                    console.error(e);
                    statusEl.textContent = 'Failed to load data.';
                }
            }

            loadBtn.addEventListener('click', async function(){
                await loadById(idInput.value);
            });
//@Srihari
            // Handle form submission smoothly
            form.addEventListener('submit', async function(e) {
                e.preventDefault(); // prevent default page reload

                submitBtn.disabled = true;
                submitBtn.textContent = "Loading...";
                if (previewBtn) previewBtn.disabled = true;
                if (resetBtn) resetBtn.disabled = true;

                try {
                    // Build a plain object from form fields
                    const fd = new FormData(form);
                    const formObj = {};
                    for (const [k, v] of fd.entries()) {
                        // If multiple fields share the same name, turn into an array
                        if (k in formObj) {
                            const cur = formObj[k];
                            if (Array.isArray(cur)) cur.push(v); else formObj[k] = [cur, v];
                        } else {
                            formObj[k] = v;
                        }
                    }

                    // Ensure unique_id is present (fallback to the loader input)
                    if (!formObj.unique_id) {
                        const uidVal = (idInput?.value || '').trim();
                        if (uidVal) formObj.unique_id = uidVal;
                    }

                    // Ensure applicant_name present; try common fallbacks
                    if (!formObj.applicant_name) {
                        let foundName = '';
                        const trySelectors = [
                            '[name="applicant_name"]',
                            '#applicant_name',
                            '[name$="applicant_name"]',
                            '[name*="applicant"][name*="name"]',
                            'input[placeholder*="Full Name" i]'
                        ];
                        for (const sel of trySelectors) {
                            const el = form.querySelector(sel);
                            if (el && el.value && String(el.value).trim()) { foundName = String(el.value).trim(); break; }
                        }
                        if (!foundName) {
                            // As a last resort, scan all inputs for first non-empty likely name field
                            const inputs = Array.from(form.querySelectorAll('input,textarea,select'));
                            for (const el of inputs) {
                                const idn = (el.id || '').toLowerCase();
                                const nn = (el.name || '').toLowerCase();
                                if ((idn.includes('applicant') && idn.includes('name')) || (nn.includes('applicant') && nn.includes('name')) || idn === 'fullname' || nn === 'fullname') {
                                    const v = (el.value || '').trim();
                                    if (v) { foundName = v; break; }
                                }
                            }
                        }
                        if (foundName) formObj.applicant_name = foundName;
                    }

                    // Validate requireds before POST
                    if (!formObj.unique_id || !formObj.applicant_name) {
                        throw new Error('Missing required fields: Unique ID and Applicant Name.');
                    }

                    // Attach comments noted (if available)
                    try {
                        if (typeof window.getCommentsData === 'function') {
                            const c = window.getCommentsData();
                            if (c && typeof c === 'object') formObj.comments_noted = c.comments_noted;
                        }
                    } catch {}

                    // Current logged-in user is sent as userId
                    const payload = {
                        userId: (localStorage.getItem('loggedInUserId') || 'Unknown Agent'),
                        formData: formObj
                    };

                    const resp = await fetch('/submit', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!resp.ok) {
                        let errorMessage = 'Please check your connection and try again.';
                        try {
                            const errorData = await resp.json();
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } catch (e) {
                            const txt = await resp.text().catch(() => '');
                            errorMessage = txt || `Server error (${resp.status})`;
                        }
                        throw new Error(errorMessage);
                    }

                    const result = await resp.json().catch(() => ({}));
                    submitBtn.textContent = "Submitted Successfully!";
                    submitBtn.style.backgroundColor = '#28a745';
                    statusEl.textContent = (result && result.message) ? result.message : 'Submission saved successfully.';
                    statusEl.style.color = 'green';
                } catch (err) {
                    console.error(err);
                    let errorMessage = err.message || 'Failed to submit. Please review required fields.';
                    
                    if (err.name === 'TypeError' && err.message.includes('fetch')) {
                        errorMessage = 'Network connection failed. Please check your internet connection.';
                    }
                    
                    statusEl.textContent = `Submission failed: ${errorMessage}`;
                    statusEl.style.color = 'red';
                    submitBtn.textContent = "Submit";
                    submitBtn.style.backgroundColor = '';
                    // Re-enable buttons on failure
                    submitBtn.disabled = false;
                    if (previewBtn) previewBtn.disabled = false;
                    if (resetBtn) resetBtn.disabled = false;
                }
            });

            // Initialize Comments Noted section (will be ready when sections load)
            setTimeout(() => {
                if (window.initializeCommentsNoted) {
                    window.initializeCommentsNoted();
                }
                // Ensure the last-modified footer is present in the actions row
                attachOrCreateLastModifiedFooter();
            }, 1000);

            // Auto-load if navigated from Client Directory or via query param
            const urlUid = new URLSearchParams(window.location.search).get('uid');
            const storedUid = localStorage.getItem('selectedUniqueId');
            const incomingUid = urlUid || storedUid;
            if (incomingUid) {
                idInput.value = incomingUid;
                try { localStorage.removeItem('selectedUniqueId'); } catch {}
                loadById(incomingUid);
            }
        });
    </script>
</body>
</html>
