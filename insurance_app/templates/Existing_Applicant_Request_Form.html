<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="/static/css/logo.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Existing Applicant Request Form</title>
    <link rel="icon" href="/static/img/icon.png" type="image/png">
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/sidebar.css">
    <link rel="stylesheet" href="../css/health_history.css">
    <link rel="stylesheet" href="../css/members.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script defer src="{{ url_for('static', filename='js/plan_selection_summary_v2.js') }}"></script>
    <style>
        .loader-bar { display:flex; gap:.5rem; align-items:center; margin: 3rem 0;}
        .loader-bar input { max-width: 240px; }
        .supervisor-meta .loader-bar label { min-width: 160px; }
        #sup-status-input { max-width: 280px; }
        .comment-box { border:1px solid #ccc; padding:8px; min-height:40px; background:#fff; }
        .form-actions { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .last-modified-inline { margin-left: auto; }
    </style>
</head>
<body data-sidebar="existing-applicant">
    
    <div class="container">
        <header class="page-header">
            <link rel="stylesheet" href="/static/css/logo.css">
            <h1>Existing Applicant Request Form</h1>
        </header>
        <p id="page-description" style="margin: 2em 0; text-align: center;">Please enter a Unique ID below and select "Load." This will instantly retrieve the saved details, allowing you to review the policy request.</p>

        <div class="loader-bar" id="member-load">
            <label for="load-unique-id"><strong>Unique ID</strong></label>
            <input id="load-unique-id" type="text" placeholder="Enter Unique ID" />
            <button id="btn-load" class="btn btn-secondary" type="button">Load</button>
        </div>
        <form id="insurance-form" novalidate>

            <p id="load-status" class="muted"></p>

            <section id="supervisor-meta" class="section supervisor-meta" style="display:none;">
                <div class="form-group" style="margin-top:8px;">
                    <div><strong>Status</strong></div>
                    <div id="sup-summary" class="comment-box" role="textbox" aria-readonly="true" style="white-space:normal; font-family: inherit; font-size: inherit; line-height:1.2; min-height: 48px; padding:0; margin:0;"></div>
                </div>
            </section>

            <div id="primary-contact-placeholder" class="section"></div>
            <div id="Health-History-placeholder" class="section"></div>
            <div id="members-covered-placeholder" class="section"></div>
            <div id="cover-cost-placeholder" class="section"></div>
            <div id="existing-coverage-placeholder" class="section"></div>
            <div id="claims-service-placeholder" class="section"></div>
            <div id="Finance-Documentation-placeholder" class="section"></div>
            <div id="comments-noted-placeholder" class="section"></div>

            <div class="form-actions">
                <button type="button" id="preview-btn" class="btn">Proceed</button>
                <button type="reset" id="reset-btn" class="btn btn-secondary">Reset</button>
                <div id="last-modified-container" class="last-modified-inline"></div>
            </div>
        </form>
    </div>

    <script src="../js/sidebar.js"></script>
    <script src="../js/calculations.js"></script>
    <script src="../js/validation.js"></script>
    <script src="../js/member_management.js"></script>
    <script src="../js/disease_details.js"></script>
    <script src="../js/comments_noted.js"></script>
    <script src="../js/occupation_data.js"></script>
    <script src="../js/occupation_dropdown.js"></script>
    <script src="../js/progress_bar.js" defer></script>
    <script src="../js/existing_prefill.js"></script>
    <script src="../js/script.js" defer></script>
    <script src="../js/data_fetch.js" defer></script>

    <script>

        function formatTimestampForDisplay(timestampStr) {
            if (!timestampStr) return '—';
            
            try {
                let dt = null;
                
                try {
                    dt = new Date(timestampStr.replace('Z', ''));
                    if (isNaN(dt.getTime())) dt = null;
                } catch (e) {}
                
                if (!dt && timestampStr.includes('_')) {
                    try {
                        const parts = timestampStr.split('_');
                        if (parts.length === 2) {
                            const datePart = parts[0];
                            const timePart = parts[1].replace(/-/g, ':');
                            dt = new Date(`${datePart}T${timePart}`);
                        }
                    } catch (e) {}
                }
                
                if (dt) {
                    return dt.toLocaleString('en-IN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true,
                        timeZone: 'Asia/Kolkata'
                    });
                }
                
                return timestampStr;
            } catch (e) {
                console.warn('Error formatting timestamp:', e);
                return timestampStr;
            }
        }

        const ROLE_STATUS = {
            OPEN_DRAFT: ['OPEN', ''],                 // OPEN or empty -> draft/open
            SUBMITTED: ['SUP_REVIEW'],                // submitted for review (supervisor reviewing)
            SUPERVISOR_REJECTED: ['SUP_REJECTED'],    // supervisor has rejected
            SUPERVISOR_APPROVED: ['SUP_APPROVED'],    // supervisor has approved, pending client
            CLIENT_APPROVED: ['client_approved'],     // client agreed
            WITH_UW: ['With_UW'],                     // underwriter stage
            POLICY_CREATED: ['Policy_Created', 'Policy created'] // normalize capitalization variants
        };

        // Normalize any incoming status value into a trimmed string
        function _normalize(s) {
            if (s === null || s === undefined) return '';
            return String(s).trim();
        }

        // Check if current user is the owner (agent) of the application
        function _isOwner(currentUserId, applicationAgent) {
            if (!currentUserId || !applicationAgent) return false;
            const currentLower = String(currentUserId).trim().toLowerCase();
            const agentLower = String(applicationAgent).trim().toLowerCase();
            // Check for exact match or partial match (user ID contained in agent field)
            return currentLower === agentLower || 
                   agentLower.includes(currentLower) || 
                   currentLower.includes(agentLower);
        }

        // Returns true if applicant details should be editable by the role at the given status
        // Now also considers ownership - agents can only edit their own applications
        function _isApplicantEditable(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);

            // AGENT: editable only when OPEN (i.e. before 'Submitted for Review') or when SUPERVISOR_REJECTED
            // AND must be the owner of the application
            if (roleL === 'agent') {
                const isOwner = _isOwner(currentUserId, applicationAgent);
                if (!isOwner) {
                    return false; // Agent cannot edit applications they don't own
                }
                if (ROLE_STATUS.OPEN_DRAFT.includes(status) || ROLE_STATUS.SUPERVISOR_REJECTED.includes(status)) {
                    return true;
                }
                return false;
            }

            // SUPERVISOR: editable only during OPEN or SUP_REVIEW (they can edit any application at these stages)
            if (roleL === 'supervisor') {
                if (ROLE_STATUS.OPEN_DRAFT.includes(status) || ROLE_STATUS.SUBMITTED.includes(status)) return true;
                return false;
            }

            // Other roles (admin, superadmin) do not edit applicant details here
            return false;
        }

        // Returns true if agent should be allowed to select plans (SUP_APPROVED stage only)
        // Agents must also be the owner of the application
        function _canAgentSelectPlans(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);
            
            // Check if status allows plan selection
            const statusAllows = ROLE_STATUS.SUPERVISOR_APPROVED.includes(status);
            if (!statusAllows) return false;
            
            // Agents must own the application
            if (roleL === 'agent') {
                return _isOwner(currentUserId, applicationAgent);
            }
            
            // Supervisors can select plans for any application at this stage
            if (roleL === 'supervisor') {
                return true;
            }
            
            return false;
        }
        // Returns true if agent or supervisor can submit to UW (CLIENT_APPROVED stage only)
        // Agents must also be the owner of the application
        function _canSubmitToUnderwriter(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);
            
            const statusAllows = ROLE_STATUS.CLIENT_APPROVED.includes(status);
            if (!statusAllows) return false;
            
            // Agents must own the application
            if (roleL === 'agent') {
                return _isOwner(currentUserId, applicationAgent);
            }
            
            // Supervisors can submit for any application
            if (roleL === 'supervisor') {
                return true;
            }
            
            return false;
        }

        /* DOM lock/unlock helpers (scoped to #insurance-form so page nav stays functional) */
        function _lockElement(el) {
            if (!el) return;
            const tag = (el.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea') {
                el.setAttribute('readonly', 'readonly');
            } else if (tag === 'select') {
                el.disabled = true;
            } else if (tag === 'button' || tag === 'a') {
                // mark disabled
                el.disabled = true;
                el.setAttribute('aria-disabled', 'true');
            }
            el.style.opacity = '0.6';
            el.style.cursor = 'not-allowed';
        }

        function _unlockElement(el) {
            if (!el) return;
            el.removeAttribute('readonly');
            el.disabled = false;
            el.removeAttribute('aria-disabled');
            el.style.opacity = '';
            el.style.cursor = '';
        }

        function _unlockEntireForm() {
            const form = document.getElementById('insurance-form');
            if (!form) return;
            form.querySelectorAll('input,select,textarea,button,a').forEach(_unlockElement);
        }

        function _lockFormExcept(exceptions = []) {
            const form = document.getElementById('insurance-form');
            if (!form) return;
            const controls = form.querySelectorAll('input,select,textarea,button,a');
            controls.forEach(el => {
                for (const ex of exceptions) {
                    if (!ex) continue;
                    if (typeof ex === 'string') {
                        try { if (el.matches && el.matches(ex)) return; } catch(e) {}
                    } else if (ex instanceof Element) {
                        if (ex.contains(el)) return;
                    }
                }
                _lockElement(el);
            });
        }

        /* Derive the canonical status for decision making from the submission data.
        Prefer application_status, then supervisor_approval_status, then underwriter_status, then client_status.
        */
        function deriveCanonicalStatusFromSubmission(data = {}) {
            if (!data || typeof data !== 'object') return '';
            const cand = [
                data.application_status,
                data.supervisor_approval_status,
                data.underwriter_status,
                data.client_status,
                data.final_status
            ];
            for (const v of cand) {
                if (v != null && String(v).trim()) return String(v).trim();
            }
            return '';
        }

        /**
         * Apply role+status restrictions.
         * role: string e.g., 'agent' | 'supervisor'
         * submissionData: the fetched submission object (may be {} on initial page load)
         * currentUserId: the logged-in user's ID
         */
        function applyRoleAndStatusRestrictions(role, submissionData, currentUserId) {
            // start from a clean slate
            _unlockEntireForm();

            const status = deriveCanonicalStatusFromSubmission(submissionData || {});
            const applicationAgent = submissionData?.agent || '';
            const applicantEditable = _isApplicantEditable(role, status, currentUserId, applicationAgent);
            const agentCanSelectPlans = _canAgentSelectPlans(role, status, currentUserId, applicationAgent);
            const canSubmitToUW = _canSubmitToUnderwriter(role, status, currentUserId, applicationAgent);

            // If applicant details editable for this role — leave everything unlocked
            if (applicantEditable) {
                return;
            }

            // Build exceptions to don't lock the navigation; 
            const exceptions = ['.tab-button', '.tab-navigation', '.btn-next', '.btn-back'];

            if (agentCanSelectPlans) {
                const plansPanel = document.getElementById('tab-panel-plans-selection');
                if (plansPanel) exceptions.push(plansPanel);
                const plansTabBtn = document.getElementById('tab-plans-selection');
                if (plansTabBtn) exceptions.push(plansTabBtn);
            }

            // perform the lock 
            _lockFormExcept(exceptions);

            // Hide reset/preview:
            ['reset-btn','preview-btn'].forEach(id => {
                const b = document.getElementById(id);
                if (b) {
                    b.classList.add('hidden');
                    b.disabled = true;
                }
            });

            if (ROLE_STATUS.WITH_UW.includes(status)) {
                const policyDecision = document.getElementById('policy-decision-select');
                if (policyDecision) {
                    _unlockElement(policyDecision);
                }
            }

            if (ROLE_STATUS.POLICY_CREATED.includes(status)) {
                const viewBtn = document.getElementById('view-policy-summary-btn');
                if (viewBtn) {
                    _unlockElement(viewBtn);
                }
            }

            // If agent can select plans, ensure plan controls are explicitly unlocked
            if (agentCanSelectPlans) {
                const plansPanel = document.getElementById('tab-panel-plans-selection');
                if (plansPanel) {
                    const planControls = plansPanel.querySelectorAll('input[type="checkbox"], .plan-checkbox, .plan-select, input.plan-select');
                    planControls.forEach(_unlockElement);
                }
            }
            // If the user can submit to UW, ensure the UW controls are unlocked
            if (canSubmitToUW) {
                const uwSection = document.getElementById('underwriter-section');
                if (uwSection) {
                    const uwControls = uwSection.querySelectorAll(
                        '#underwriter-approve, #underwriter-comment, #save-underwriter-decision'
                    );
                    uwControls.forEach(_unlockElement);
                    
                }
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const statusEl = document.getElementById('load-status');
            const loadBtn = document.getElementById('btn-load');
            const idInput = document.getElementById('load-unique-id');
            const form = document.getElementById('insurance-form');
            const previewBtn = document.getElementById('preview-btn');
            const resetBtn = document.getElementById('reset-btn');

            function setActionButtonsEnabled(enabled) {
                if (previewBtn) previewBtn.disabled = !enabled;
                if (resetBtn) resetBtn.disabled = !enabled;
            }

            const userId = localStorage.getItem('loggedInUserId');

            if (!userId) {
                window.location.href = 'Main_login.html';
            }

            async function addPlansTab(uniqueId) {
                const tabNav = document.querySelector('.tab-navigation');
                const tabContentContainer = document.querySelector('.tab-content-container');
                
                if (!tabNav || !tabContentContainer) return;
                if (document.getElementById('tab-plans-selection')) return;
                
                const tabIndex = 8;
                
                const li = document.createElement('li');
                li.setAttribute('role', 'presentation');
                
                const button = document.createElement('button');
                button.className = 'tab-button';
                button.setAttribute('role', 'tab');
                button.setAttribute('aria-selected', 'false');
                button.setAttribute('aria-controls', 'tab-panel-plans-selection');
                button.setAttribute('id', 'tab-plans-selection');
                button.setAttribute('type', 'button');
                button.textContent = 'Plans';
                button.dataset.index = tabIndex;
                
                button.addEventListener('click', () => {
                    document.querySelectorAll('.tab-button').forEach((btn, i) => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-selected', 'false');
                    });
                    button.classList.add('active');
                    button.setAttribute('aria-selected', 'true');
                    
                    document.querySelectorAll('.tab-content-wrapper').forEach(wrapper => {
                        wrapper.classList.remove('active');
                    });
                    const plansWrapper = document.getElementById('tab-panel-plans-selection');
                    if (plansWrapper) plansWrapper.classList.add('active');
                });
                
                li.appendChild(button);
                tabNav.appendChild(li);
                
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'tab-content-wrapper';
                contentWrapper.setAttribute('role', 'tabpanel');
                contentWrapper.setAttribute('id', 'tab-panel-plans-selection');
                contentWrapper.setAttribute('aria-labelledby', 'tab-plans-selection');
                contentWrapper.dataset.index = tabIndex;
                
                const contentDiv = document.createElement('div');
                contentDiv.id = 'plans-selection-content';
                contentWrapper.appendChild(contentDiv);
                
                const navButtons = document.createElement('div');
                navButtons.className = 'tab-navigation-buttons';
                
                const backBtn = document.createElement('button');
                backBtn.type = 'button';
                backBtn.className = 'btn tab-nav-btn btn-back';
                backBtn.textContent = 'Back';
                backBtn.addEventListener('click', () => {
                    const commentsTab = document.getElementById('tab-comments-noted');
                    if (commentsTab) commentsTab.click();
                });
                
                navButtons.appendChild(backBtn);
                contentWrapper.appendChild(navButtons);
                
                tabContentContainer.appendChild(contentWrapper);
                
                if (typeof window.renderPlansTab === 'function') {
                    await window.renderPlansTab(contentDiv, uniqueId);
                }
            }

            const userRole = localStorage.getItem('userRole');
            applyRoleAndStatusRestrictions(userRole, {}, userId); // no submission data yet; safe initial call


            function hardResetForm() {
                try {
                    localStorage.removeItem('members');
                    localStorage.removeItem('formSummary');
                    localStorage.removeItem('submissionData');
                    localStorage.removeItem('plans');
                    localStorage.removeItem('editMemberId');
                    localStorage.removeItem('comments_noted');
                    sessionStorage.removeItem('currentUniqueId');

                    if (form) {
                        form.reset();
                        const ctrls = form.querySelectorAll('input, select, textarea');
                        ctrls.forEach(el => {
                            const tag = (el.tagName || '').toLowerCase();
                            const type = (el.type || '').toLowerCase();
                            if (tag === 'input') {
                                if (type === 'checkbox' || type === 'radio') {
                                    el.checked = false;
                                } else {
                                    el.value = '';
                                }
                            } else if (tag === 'select') {
                                el.selectedIndex = 0;
                            } else if (tag === 'textarea') {
                                el.value = '';
                            }
                        });
                    }

                    try {
                        const membersList = document.getElementById('members-list');
                        if (membersList) membersList.innerHTML = '';
                        const summaryContent = document.getElementById('summary-content');
                        if (summaryContent) summaryContent.innerHTML = '<p class="placeholder-text">Hover over a member to see their details.</p>';
                        if (window.loadMembersGlobal) window.loadMembersGlobal();
                        if (window.updatePeopleCounter) window.updatePeopleCounter();
                    } catch(e) { }

                    try {
                        if (typeof window.clearCommentsSession === 'function') {
                            window.clearCommentsSession();
                        } else {
                            const tb = document.getElementById('comments-tbody');
                            if (tb) tb.innerHTML = '';
                            const tbl = document.getElementById('comments-table');
                            if (tbl) tbl.style.display = 'none';
                            const noMsg = document.getElementById('no-comments-message');
                            if (noMsg) noMsg.style.display = 'block';
                        }
                    } catch(e) { }

                    statusEl.textContent = '';
                    const supSummary = document.getElementById('sup-summary');
                    if (supSummary) supSummary.textContent = '';
                    const lastMod = document.getElementById('last-modified-footer');
                    if (lastMod) lastMod.style.display = 'none';

                    // Clear progress bar and its data
                    try {
                        window.currentSubmissionData = null;
                        localStorage.removeItem('currentUniqueId');
                        const progressBar = document.querySelector('.progress-bar-container');
                        if (progressBar) progressBar.remove();
                    } catch(e) { }

                    setActionButtonsEnabled(true);
                } catch (e) {
                    console.warn('Hard reset encountered an issue:', e);
                }
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', function(ev){
                    ev.preventDefault();
                    hardResetForm();
                });
            }

            function attachOrCreateLastModifiedFooter() {
                const host = document.getElementById('last-modified-container');
                if (!host) return;
                let footer = document.getElementById('last-modified-footer');
                if (!footer) {
                    footer = document.createElement('div');
                    footer.id = 'last-modified-footer';
                    footer.className = 'last-modified-footer';
                    footer.style.display = 'none';
                    footer.innerHTML = 'Last Modified by <span id="last-modified-by">—</span> on <span id="last-modified-date">—</span>';
                } else if (footer.parentElement !== host) {
                    footer.parentElement.removeChild(footer);
                }
                host.appendChild(footer);
            }

            function updateMainLastModified(data) {
                attachOrCreateLastModifiedFooter();
                const footer = document.getElementById('last-modified-footer');
                const lastModifiedBy = document.getElementById('last-modified-by');
                const lastModifiedDate = document.getElementById('last-modified-date');
                if (!footer || !lastModifiedBy || !lastModifiedDate) return;

                let modifiedBy = '—';
                let modifiedAt = null;

                const timestampSources = [
                    { by: data.application_modified_by, at: data.application_modified_at, source: 'final' },
                    { by: data.underwriter_modified_by, at: data.underwriter_modified_at, source: 'underwriter' },
                    { by: data.supervisor_modified_by, at: data.supervisor_modified_at, source: 'supervisor' },
                    { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at, source: 'policy' },
                    { by: data.close_status_modified_by, at: data.close_status_modified_at, source: 'application' },
                    { by: data.first_created_by, at: data.first_created_at, source: 'created' }
                ];
                
                const validTimestamps = timestampSources
                    .filter(ts => ts.by && ts.at)
                    .sort((a, b) => {
                        try {
                            const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                            const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                            return dateB - dateA;
                        } catch (e) {
                            return 0;
                        }
                    });
                
                if (validTimestamps.length > 0) {
                    const latest = validTimestamps[0];
                    modifiedBy = latest.by;
                    modifiedAt = latest.at;
                }

                let formattedDate = '—';
                if (modifiedAt) {
                    formattedDate = formatTimestampForDisplay(modifiedAt);
                }

                lastModifiedBy.textContent = modifiedBy;
                lastModifiedDate.textContent = formattedDate;
                footer.style.display = 'block';
            }

            function updateWorkflowButtons(applicationStatus, userRole) {
                const status = (applicationStatus || '').trim();
                console.log("Workflow Button Status:", status, "Role:", userRole);

                // Use querySelector to ensure elements are rtrieved when they're in the plans tab
                const policyDecisionSelect = document.getElementById('policy-decision-select');
                const policyDecisionLabel = document.getElementById('policy-decision-label');
                const viewSummaryBtn = document.getElementById('view-policy-summary-btn');
                
                // Hide/disable everything by default
                if (policyDecisionSelect) {
                    policyDecisionSelect.style.display = 'none';
                    policyDecisionSelect.disabled = true;
                }
                if (policyDecisionLabel) { 
                    policyDecisionLabel.style.display = 'none';
                }
                if (viewSummaryBtn) {
                    viewSummaryBtn.style.display = 'none';
                }

                const normalizedStatus = (applicationStatus || '').toUpperCase().trim();
                
                // Show the dropdown when the status is 'With_UW'
                const showDecisionDropdown = normalizedStatus === 'WITH_UW';
                // Show the view summary button when the status is 'Policy_Created' or 'Policy_Denied'
                const showViewSummaryButton = normalizedStatus === 'POLICY_CREATED' || normalizedStatus === 'POLICY_DENIED';
                
                if (policyDecisionSelect && showDecisionDropdown) {
                    policyDecisionSelect.style.display = 'inline-block';
                    policyDecisionSelect.disabled = false;
                }

                if (policyDecisionLabel && showDecisionDropdown) { 
                    policyDecisionLabel.style.display = 'inline-block'; 
                }

                if (viewSummaryBtn && showViewSummaryButton) {
                    viewSummaryBtn.style.display = 'inline-block';
                }
            }

            async function loadById(uniqueId) {
                const uid = (uniqueId || '').trim();
                statusEl.textContent = '';
                if (!uid) { statusEl.textContent = 'Please enter Unique ID.'; return; }
                
                const allControls = document.querySelectorAll('input, select, textarea');
                allControls.forEach(el => {
                    el.removeAttribute('readonly');
                    el.disabled = false;
                    el.style.cursor = '';
                    el.style.opacity = '';
                    el.style.backgroundColor = '';
                });
                
                try {
                    const resp = await fetch(`/api/agent/submission/${encodeURIComponent(uid)}`);
                    if (!resp.ok) { statusEl.textContent = 'Submission not found.'; return; }
                    const data = await resp.json();
                    console.log('Raw data from API:', data);
                    let formPayload = null;
                    try {
                        if (typeof data.form_summary === 'string') {
                            formPayload = JSON.parse(data.form_summary);
                        } else if (data.form_summary && typeof data.form_summary === 'object') {
                            formPayload = data.form_summary;
                        }
                    } catch (e) { formPayload = null; }
                    console.log('Parsed formPayload:', formPayload)
                    if (!formPayload) {
                        try {
                            const legacy = await fetch(`/submission/${encodeURIComponent(uid)}`);
                            if (legacy.ok) {
                                formPayload = await legacy.json();
                            }
                        } catch (e) { }
                    }
                    
                    if (!formPayload) formPayload = data;
                    console.log('Final formPayload being sent to prefill:', formPayload);
                    if (window.prefillExistingForm) {
                        await window.prefillExistingForm(formPayload);
                        statusEl.textContent = 'Data loaded. You can edit and save.';
                    } else {
                        statusEl.textContent = 'Prefill function not available.';
                    }
                    if (window.initializeDiseaseDetails) {
                        setTimeout(() => {
                            window.initializeDiseaseDetails();
                        }, 500);
                    }

                    localStorage.setItem('currentUniqueId', uid);
                    if (window.initializeCommentsNoted) {
                        window.initializeCommentsNoted();
                    }
                    if (window.loadExistingComments) {
                        window.loadExistingComments(uid);
                    }

                    updateMainLastModified(data);

                    const supSection = document.getElementById('supervisor-meta');
                    const supSummary = document.getElementById('sup-summary');
                    if (supSection) supSection.style.display = '';
                    if (supSummary) supSummary.textContent = 'Loading status...';

                    // Use an async IIFE to properly handle the progress bar update
                    (async () => {
                        const statusDisp = (data.final_status && String(data.final_status).trim())
                            ? data.final_status
                            : (data.application_status || data.supervisor_approval_status || 'Open');

                        console.log("DEBUGGING: About to update progress bar with", statusDisp);

                        // Store submission data globally for progress bar to access timestamps
                        window.currentSubmissionData = data;

                        // Helper function to wait for progress bar script to load
                        const waitForProgressBar = (maxWaitMs = 5000) => {
                            return new Promise((resolve) => {
                                if (typeof window.updateProgressBar === 'function') {
                                    resolve(true);
                                    return;
                                }
                                const startTime = Date.now();
                                const checkInterval = setInterval(() => {
                                    if (typeof window.updateProgressBar === 'function') {
                                        clearInterval(checkInterval);
                                        resolve(true);
                                    } else if (Date.now() - startTime >= maxWaitMs) {
                                        clearInterval(checkInterval);
                                        console.warn("Progress bar script did not load in time");
                                        resolve(false);
                                    }
                                }, 50);
                            });
                        };

                        // Wait for progress bar to be available, then update it
                        const progressBarReady = await waitForProgressBar();
                        if (progressBarReady) {
                            // Use application_status as primary, fall back to supervisor_approval_status
                            const progressStatus = data.application_status || data.supervisor_approval_status || 'OPEN';
                            try {
                                await window.updateProgressBar(progressStatus);
                                console.log("Progress bar updated successfully with status:", progressStatus);
                            } catch (err) {
                                console.error("Error updating progress bar:", err);
                            }
                        }

                        const comments = (data.application_comments && String(data.application_comments).trim()) ? data.application_comments : 'No notes';
                        let tsStr = '—';
                        let by = '—';
                        const timestampSources = [
                            { by: data.application_modified_by, at: data.application_modified_at },
                            { by: data.underwriter_modified_by, at: data.underwriter_modified_at },
                            { by: data.supervisor_modified_by, at: data.supervisor_modified_at },
                            { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at },
                            { by: data.close_status_modified_by, at: data.close_status_modified_at },
                            { by: data.agent, at: data.timestamp },
                            { by: data.first_created_by, at: data.first_created_at }
                        ];

                        const validTimestamps = timestampSources
                            .filter(ts => ts.by && ts.at)
                            .sort((a, b) => {
                                try {
                                    const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                                    const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                                    return dateB - dateA;
                                } catch (e) {
                                    return 0;
                                }
                            });

                        if (validTimestamps.length > 0) {
                            const latest = validTimestamps[0];
                            by = latest.by;
                            tsStr = formatTimestampForDisplay(latest.at);
                        }

                        const summaryHtml = `<strong>Application Status:</strong> ${statusDisp}<br>
                                            <strong>Notes:</strong> ${comments}<br>
                                            <strong>Last Updated by:</strong> ${by} <strong>Last Updated at:</strong> ${tsStr}`;
                        if (supSummary) supSummary.innerHTML = summaryHtml;

                    })();

                    if (!data.final_status) {
                        try {
                            const metaResp = await fetch(`/submission/${encodeURIComponent(uid)}/meta`);
                            if (metaResp.ok) {
                                const meta = await metaResp.json();
                                if (supSummary) {
                                    const raw = (meta.supervisor_status || '').toString();
                                    const normalized = raw.trim().toUpperCase();
                                    const statusDisp = normalized === 'OPEN' ? 'Open' : (raw || 'Open');
                                    const comments = (meta.supervisor_comments && String(meta.supervisor_comments).trim()) ? meta.supervisor_comments : 'No notes';
                                    let tsStr = '—';
                                    if (meta.supervisor_modified_at) {
                                        tsStr = formatTimestampForDisplay(meta.supervisor_modified_at);
                                    }
                                    const by = meta.supervisor_modified_by || '—';
                                    const summaryHtml = '<strong>Application Status:</strong> ' + statusDisp + '<br>' +
                                                    '<strong>Supervisor Notes:</strong> ' + comments + '<br>' +
                                                    '<strong>Last Updated by:</strong> ' + by + ' <strong>Last Updated at:</strong> ' + tsStr;
                                    supSummary.innerHTML = summaryHtml;

                                    const norm = String(statusDisp || '').trim().toUpperCase();
                                    const allowed = (norm === 'OPEN' || norm === 'SUP_REJECTED');
                                    setActionButtonsEnabled(allowed);
                                }
                            }
                        } catch (e) {
                            console.warn('Failed to fetch supervisor meta', e);
                        }
                    }
                    
                    const statusForTab = (data.final_status || data.supervisor_approval_status || '').toUpperCase();
                    if (statusForTab === 'SUP_APPROVED') {
                        await addPlansTab(uid);
                    }

                    const userRole = localStorage.getItem('userRole');
                    updateWorkflowButtons(data.application_status, userRole);
                    if (userRole) {
                        applyRoleAndStatusRestrictions(userRole, data, userId);
                    }

                    
                } catch (e) {
                    console.error(e);
                    statusEl.textContent = 'Failed to load data.';
                }
            }

            loadBtn.addEventListener('click', async function(){
                await loadById(idInput.value);
            });

            (async function autoLoadFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const uidFromUrl = urlParams.get('uid');
                if (uidFromUrl) {
                    console.log('Auto-loading from URL parameter:', uidFromUrl);
                    // Set the input field value so user sees what's being loaded
                    if (idInput) {
                        idInput.value = uidFromUrl;
                    }
                    // Wait a bit for sections to load before calling loadById
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await loadById(uidFromUrl);
                }
            })();

            if (previewBtn) {
                previewBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    
                    // Trigger form submission which will run all validation
                    const submitEvent = new Event('submit', {
                        bubbles: true,
                        cancelable: true
                    });
                    form.dispatchEvent(submitEvent);
                });
            }


            form.addEventListener('submit', async function(e) {
                e.preventDefault();

                if (previewBtn) {
                    previewBtn.disabled = true;
                    previewBtn.textContent = "Submitting...";
                }
                if (resetBtn) resetBtn.disabled = true;

                try {
                    // Disease date validation for primary applicant
                    const healthHistoryContent = document.getElementById('health-history-content');
                    if (healthHistoryContent) {
                        const diseaseEntries = healthHistoryContent.querySelectorAll('.disease-entry');
                        const diseaseErrors = [];

                        diseaseEntries.forEach(entry => {
                            const checkbox = entry.querySelector('input[type="checkbox"][name="disease"], input[type="checkbox"]');
                            const dateInput = entry.querySelector('.disease-date-input');
                            const errorSpan = entry.querySelector('.error-message');

                            if (!checkbox || !dateInput) return;

                            // Clear any previous error state
                            if (errorSpan) {
                                errorSpan.textContent = '';
                                errorSpan.style.display = 'none';
                            }
                            dateInput.classList.remove('input-error');

                            // Only validate if disease is selected
                            if (checkbox.checked) {
                                if (!dateInput.value || dateInput.value.trim() === '') {
                                    const headerLabel = entry.querySelector('.disease-header label');
                                    const diseaseLabel = headerLabel ? headerLabel.textContent.trim() : 'the selected disease';
                                    diseaseErrors.push(`Disease start date for ${diseaseLabel} is required`);
                                    if (errorSpan) {
                                        errorSpan.textContent = 'Disease start date is required';
                                        errorSpan.style.display = 'block';
                                    }
                                    dateInput.classList.add('input-error');
                                } else {
                                    // Also validate date is not in the future
                                    const selectedDate = new Date(dateInput.value);
                                    const today = new Date();
                                    today.setHours(0, 0, 0, 0);
                                    
                                    if (selectedDate > today) {
                                        const headerLabel = entry.querySelector('.disease-header label');
                                        const diseaseLabel = headerLabel ? headerLabel.textContent.trim() : 'the selected disease';
                                        diseaseErrors.push(`Disease start date for ${diseaseLabel} cannot be in the future`);
                                        if (errorSpan) {
                                            errorSpan.textContent = 'Date cannot be in the future';
                                            errorSpan.style.display = 'block';
                                        }
                                        dateInput.classList.add('input-error');
                                    }
                                }
                            }
                        });

                        // If there are disease date errors, stop submission
                        if (diseaseErrors.length > 0) {
                            alert('Please fix the following errors before submitting:\n\n• ' + diseaseErrors.join('\n• '));
                            
                            if (previewBtn) {
                                previewBtn.textContent = "Proceed";
                                previewBtn.disabled = false;
                            }
                            if (resetBtn) resetBtn.disabled = false;
                            
                            // Scroll to first error
                            const firstError = healthHistoryContent.querySelector('.input-error');
                            if (firstError) {
                                firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                setTimeout(() => firstError.focus(), 300);
                            }
                            
                            return false;
                        }
                    }

                    const uniqueId = (idInput?.value || '').trim();
                    
                    const formObj = {};
                    const allInputs = form.querySelectorAll('input, select, textarea');
                    
                    // Get reference to members section to identify inputs we should skip
                    const membersCoveredContent = document.getElementById('members-covered-content');

                    allInputs.forEach(el => {
                        if (!el.name) return;
                        if (el.disabled) return; // skip disabled/read-only fields entirely
                        
                        if (membersCoveredContent && membersCoveredContent.contains(el)) {
                            // This input is inside the members section
                            // Member data is handled separately via localStorage 'members'
                            return;
                        }
                        
                        // Also skip inputs inside any .member-form container
                        if (el.closest('.member-form') || el.closest('.member-tab-content')) {
                            return;
                        }

                        const k = el.name;
                        const v = el.value;

                        if (el.type === 'radio') {
                            if (el.checked) formObj[k] = v;
                        } else if (el.type === 'checkbox') {
                            if (!formObj[k]) formObj[k] = [];
                            if (el.checked) formObj[k].push(v);
                        } else {
                            if (k in formObj) {
                                const cur = formObj[k];
                                if (Array.isArray(cur)) cur.push(v);
                                else formObj[k] = [cur, v];
                            } else {
                                formObj[k] = v;
                            }
                        }
                    });


                    if (!formObj.unique_id) {
                        if (uniqueId) formObj.unique_id = uniqueId;
                    }

                    if (!formObj.applicant_name) {
                        let foundName = '';
                        const trySelectors = [
                            '[name="applicant_name"]', '#applicant_name',
                            '[name$="applicant_name"]', '[name*="applicant"][name*="name"]',
                            'input[placeholder*="Full Name" i]'
                        ];
                        for (const sel of trySelectors) {
                            const el = form.querySelector(sel);
                            if (el && el.value && String(el.value).trim()) { 
                                foundName = String(el.value).trim(); 
                                break; 
                            }
                        }
                        if (foundName) formObj.applicant_name = foundName;
                    }

                    if (!formObj.unique_id || !formObj.applicant_name) {
                        throw new Error('Missing required fields: Unique ID and Applicant Name.');
                    }

                    try {
                        if (typeof window.getCommentsData === 'function') {
                            const c = window.getCommentsData();
                            if (c && typeof c === 'object') formObj.comments_noted = c.comments_noted;
                        }
                    } catch {}

                    // ====================================================================
                    // CRITICAL: Include members in formObj for server submission
                    // Members are stored separately in localStorage but MUST be sent to server
                    // ====================================================================
                    try {
                        const membersData = JSON.parse(localStorage.getItem('members')) || [];
                        if (membersData.length > 0) {
                            formObj.members = membersData;
                            console.log('Including', membersData.length, 'member(s) in submission');
                        }
                    } catch (e) {
                        console.warn('Error reading members from localStorage:', e);
                    }

                    const userId = localStorage.getItem('loggedInUserId');
                    if (!userId) {
                        throw new Error('User not logged in. Please log in and try again.');
                    }

                    const payload = {
                        userId: userId,
                        formData: formObj
                    };
                    if (window.clearProgressTimestamps) {
                        window.clearProgressTimestamps(formObj.unique_id);
                    }

                    const resp = await fetch('/submit', {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'X-User-Id': userId
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!resp.ok) {
                        let errorMessage = 'Please check your connection and try again.';
                        try {
                            const errorData = await resp.json();
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } catch (e) {
                            const txt = await resp.text().catch(() => '');
                            errorMessage = txt || `Server error (${resp.status})`;
                        }
                        throw new Error(errorMessage);
                    }

                    const result = await resp.json().catch(() => ({}));

                    const summaryData = {
                        primaryContact: {},
                        healthHistory: {},
                        members: JSON.parse(localStorage.getItem('members')) || [],
                        coverAndCost: {},
                        existingCoverage: {},
                        claimsAndService: {},
                        financeAndDocumentation: {},
                        commentsNoted: window.getCommentsData ? window.getCommentsData() : { comments_noted: [] }
                    };

                    // Prefer the same section-based logic used by the New Applicant flow
                    if (typeof window.getSectionData === 'function') {
                        // Primary Contact
                        summaryData.primaryContact = window.getSectionData('primary-contact') || {};
                        summaryData.primaryContact['unique_id'] = formObj.unique_id;

                        // Health History
                        summaryData.healthHistory = window.getSectionData('health-history') || {};

                        // Other sections
                        summaryData.coverAndCost = window.getSectionData('cover-cost') || {};
                        summaryData.existingCoverage = window.getSectionData('existing-coverage') || {};
                        summaryData.claimsAndService = window.getSectionData('claims-service') || {};
                        summaryData.financeAndDocumentation = window.getSectionData('finance-documentation') || {};
                    } else {
                        // Fallback: legacy mapping if getSectionData is not available
                        summaryData.primaryContact['unique_id'] = formObj.unique_id;

                        Object.keys(formObj).forEach(key => {
                            const value = formObj[key];

                            if (key === 'unique_id') return;

                            if ([
                                'applicant_name', 'gender', 'email', 'phone', 'address',
                                'self-dob', 'self-height', 'self-weight', 'self-age',
                                'occupation', 'city', 'hubs'
                            ].includes(key)) {
                                summaryData.primaryContact[key] = value;
                            }
                            else if (
                                key.startsWith('medical-') || key.startsWith('medical_') ||
                                key.startsWith('disease-') || key.startsWith('disease_') ||
                                key === 'self-details' || key === 'self_details' ||
                                key === 'disease' || key.endsWith('_details') || key.endsWith('_start_date')
                            ) {
                                summaryData.healthHistory[key] = value;
                            }
                            else if ([
                                'policy-type', 'sum-insured', 'annual-budget', 'payment-mode',
                                'room-preference', 'co-pay', 'ncb-importance', 'maternity-cover',
                                'opd-cover', 'top-up'
                            ].includes(key)) {
                                summaryData.coverAndCost[key] = value;
                            }
                            else if ([
                                'existing-policies', 'port-policy', 'critical-illness', 'worldwide-cover',
                                'policy-type-category', 'insurer-name', 'existing-policy-number', 
                                'existing-sum-insured', 'policy-since-date'
                            ].includes(key)) {
                                summaryData.existingCoverage[key] = value;
                            }
                            else if ([
                                'past-claims', 'claim-issues', 'service-expectations', 'network-hospitals'
                            ].includes(key)) {
                                summaryData.claimsAndService[key] = value;
                            }
                            else if (['tax-benefit', 'address_proof_details', 'gst-number'].includes(key)) {
                                summaryData.financeAndDocumentation[key] = value;
                            }
                        });
                    }


                    localStorage.setItem('formSummary', JSON.stringify(summaryData));
                    localStorage.setItem('submissionData', JSON.stringify(formObj));
                    if (result.plans) {
                        localStorage.setItem('plans', JSON.stringify(result.plans));
                    }

                    if (previewBtn) {
                        previewBtn.textContent = 'Submitted Successfully!';
                        previewBtn.style.backgroundColor = '#28a745';
                    }

                    alert('Form submitted successfully!\n\nSubmission ID: ' + (result.submissionId || formObj.unique_id));
                    
                    window.location.href = `Summary.html?unique_id=${encodeURIComponent(formObj.unique_id)}`;

                } catch (err) {
                    console.error(err);
                    let errorMessage = err.message || 'Failed to submit. Please review required fields.';
                    
                    if (err.name === 'TypeError' && err.message.includes('fetch')) {
                        errorMessage = 'Network connection failed. Please check your internet connection.';
                    }
                    
                    alert(`Submission failed: ${errorMessage}`);
                    
                    statusEl.textContent = `Submission failed: ${errorMessage}`;
                    statusEl.style.color = 'red';
                    if (previewBtn) {
                        previewBtn.textContent = "Submit";
                        previewBtn.style.backgroundColor = '';
                        previewBtn.disabled = false;
                    }
                    if (resetBtn) resetBtn.disabled = false;
                }
            });


        window.renderPlansTab = async function(container, uniqueId) {
            if (!container || !uniqueId) return;

            container.innerHTML = '<p>Loading plans...</p>';

            try {
                let planSummaryData = null;
                try {
                    const resp = await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}`);
                    if (resp.ok) planSummaryData = await resp.json();
                } catch (e) {
                    console.warn('Could not load from plan_summary endpoint:', e);
                }

                if (!planSummaryData || !planSummaryData.proposed || Object.keys(planSummaryData.proposed).length === 0) {
                    try {
                        const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                        if (submissionResp.ok) {
                            const submissionData = await submissionResp.json();
                            let proposedPlans = submissionData.proposed_plans;
                            if (proposedPlans && typeof proposedPlans === 'string') {
                                proposedPlans = JSON.parse(proposedPlans);
                            }
                            if (proposedPlans && Object.keys(proposedPlans).length > 0) {
                                await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/init_or_update`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ proposed: proposedPlans })
                                });
                                const resp2 = await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}`);
                                if (resp2.ok) planSummaryData = await resp2.json();
                            }
                        }
                    } catch (e) {
                        console.error('Error initializing plan_summary from submission:', e);
                    }
                }

                let agentSelected = [];
                if (planSummaryData?.agent_selected) {
                    agentSelected = Array.isArray(planSummaryData.agent_selected) ? planSummaryData.agent_selected : [];
                }
                if (agentSelected.length === 0) {
                    try {
                        const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                        if (submissionResp.ok) {
                            const submissionData = await submissionResp.json();
                            const possibleFields = ['agent_selected_plans', 'Agent_Selected_Plans', 'chosen_plans', 'plans_chosen'];
                            for (const field of possibleFields) {
                                if (submissionData[field]) {
                                    try {
                                        const parsed = typeof submissionData[field] === 'string'
                                            ? JSON.parse(submissionData[field])
                                            : submissionData[field];
                                        if (Array.isArray(parsed) && parsed.length > 0) {
                                            agentSelected = parsed;
                                            break;
                                        }
                                    } catch (e) {}
                                }
                            }
                            if (agentSelected.length > 0) {
                                try {
                                    await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/agent`, {
                                        method: 'PATCH',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ agent_selected: agentSelected })
                                    });
                                } catch (e) {
                                    console.error('Failed to sync agent selections:', e);
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error loading agent selections from submission:', e);
                    }
                }

                const proposed = planSummaryData?.proposed || {};
                const agentSel = new Set(agentSelected);
                const supervisorSel = new Set(planSummaryData?.supervisor_selected || []);
                const clientSel = new Set(planSummaryData?.client_agreed || []);

                let submissionData = {};
                try {
                    const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                    if (submissionResp.ok) submissionData = await submissionResp.json();
                } catch (e) {
                    console.warn('Could not load submission data for status check:', e);
                }

                const clientStatus = (submissionData.client_status || '').toLowerCase();
                const underwriterStatus = (submissionData.underwriter_status || '').toLowerCase();
                const showUnderwriterSection = clientStatus === 'client_approved';

                container.innerHTML = `
                    <div style="padding: 1rem;">
                        <h2>Plan Selection</h2>
                        <p>Review the plans selected by the agent and supervisor, then select the plans you agree to.</p>
                        <div id="plans-selection-matrix" style="margin-top: 1rem;"></div>
                        <div style="margin-top: 1rem;">
                            <textarea id="client-plans-comment" rows="3" style="width: 100%; margin-bottom: 0.5rem;" placeholder="Add your notes about the selected plans"></textarea>
                        </div>
                        <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                            <button type="button" id="save-client-plans" class="btn">Save Client Selection</button>
                            <span id="client-plans-status" style="margin-left: 1rem;"></span>
                        </div>

                        <div id="underwriter-section" style="display: ${showUnderwriterSection ? 'block' : 'none'}; border-top: 2px solid #eee; padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 0.5rem;">Underwriter Submission Review</h3>
                            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                                Review the client's agreed plans and submit to underwriter.
                            </p>

                            <div style="background: #f9f9f9; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
                                <strong style="display: block; margin-bottom: 0.5rem;">Client Agreed Plans:</strong>
                                <div id="client-agreed-display" style="margin-left: 1rem;">
                                    ${Array.from(clientSel).length > 0 
                                        ? Array.from(clientSel).map(p => `<div style="margin-bottom: 0.25rem;">• ${p}</div>`).join('')
                                        : '<em style="color: #888;">No plans selected by client yet</em>'
                                    }
                                </div>
                                ${submissionData.client_comments ? `
                                    <div style="margin-top: 0.75rem;">
                                        <strong style="display: block; margin-bottom: 0.25rem;">Client Notes:</strong>
                                        <div style="margin-left: 1rem; color: #555;">${submissionData.client_comments}</div>
                                    </div>
                                ` : ''}
                            </div>

                            <div style="margin-top: 1rem;">
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                        <input type="checkbox" id="underwriter-approve" checked>
                                        <span style="color: #007bff; font-weight: 600;">Submit to Underwriter</span>
                                    </label>
                                </div>

                                <label for="underwriter-comment" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">
                                    Notes
                                </label>
                                <textarea id="underwriter-comment" rows="3" 
                                        style="width: 100%; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;" 
                                        placeholder="Enter underwriter notes">${submissionData.underwriter_comments || ''}</textarea>

                                <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                                    <button type="button" id="save-underwriter-decision" class="btn">Submit</button>
                                    <span id="underwriter-decision-status" style="margin-left: 1rem;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="workflow-actions" style="margin-top: 2rem; border-top: 2px solid #eee; padding-top: 1.5rem; display: flex; gap: 10px; align-items: center;">
                            <label for="policy-decision-select" id="policy-decision-label" style="font-weight: 600;">Final Policy Decision:</label>
                            <select id="policy-decision-select" class="form-control" style="max-width: 200px;" disabled>
                                <option value="" disabled selected>Select an action</option>
                                <option value="policy_created">Policy Created</option>
                                <option value="policy_denied">Policy Denied</option>
                            </select>
                            <span id="policy-decision-status" style="margin-left: 10px;"></span>

                            <button type="button" id="view-policy-summary-btn" class="btn" style="display: none; background-color: #10b981;">
                                <i class="fas fa-file-alt" style="margin-right: 6px;"></i>
                                View Policy Summary
                            </button>
                        </div>
                    </div>
                `;

                const matrixHost = container.querySelector('#plans-selection-matrix');
                const commentEl = container.querySelector('#client-plans-comment');
                const saveBtn = container.querySelector('#save-client-plans');
                const statusEl = container.querySelector('#client-plans-status');

                if (typeof window.renderPlanSelectionSummary === 'function') {
                    window.renderPlanSelectionSummary(matrixHost, {
                        proposed,
                        agentSel,
                        supervisorSel,
                        clientSel,
                        mode: 'approvals',
                        onClientToggle: async (planName, checked) => {
                            if (checked) clientSel.add(planName);
                            else clientSel.delete(planName);

                            try {
                                await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/client`, {
                                    method: 'PATCH',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ client_agreed: Array.from(clientSel) })
                                });
                            } catch (e) {
                                console.error('Failed to save client selection:', e);
                            }
                        }
                    });
                }

                // Pre-fill saved client selections if they exist
                try {
                    const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                    if (submissionResp.ok) {
                        const submissionData = await submissionResp.json();
                        
                        if (submissionData.client_comments) {
                            commentEl.value = submissionData.client_comments;
                        }

                        if (submissionData.Client_Agreed_Plans) {
                            try {
                                const savedPlans = JSON.parse(submissionData.Client_Agreed_Plans);
                                if (Array.isArray(savedPlans) && savedPlans.length > 0) {
                                    savedPlans.forEach(planName => {
                                        clientSel.add(planName);
                                        const checkbox = matrixHost.querySelector(`input.pss-client[data-plan-name="${planName}"]`);
                                        if (checkbox) checkbox.checked = true;
                                    });
                                }
                            } catch (e) { 
                                console.error('Error parsing saved plans:', e); 
                            }
                        }
                    }
                } catch (e) { 
                    console.error('Error loading existing selections:', e); 
                }

                // Client save handler - never lock, always allow re-doing
                if (saveBtn) {
                    saveBtn.addEventListener('click', async () => {
                        const selected = Array.from(clientSel);
                        const comment = (commentEl?.value || '').trim();

                        if (selected.length === 0) {
                            statusEl.textContent = 'Please select at least one plan.';
                            statusEl.style.color = 'red';
                            return;
                        }

                        saveBtn.disabled = true;
                        saveBtn.textContent = 'Saving...';
                        statusEl.textContent = '';

                        try {
                            const resp = await fetch('/api/agent/update_status', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                                },
                                body: JSON.stringify({
                                    unique_id: uniqueId,
                                    actor: 'client',
                                    client_review: true,
                                    status: 'client_reviewed',
                                    comment: comment || 'Client agreed to selected plans',
                                    client_agreed_plans: selected,
                                    client_status: 'client_approved'
                                })
                            });

                            if (!resp.ok) {
                                const errorText = await resp.text().catch(() => '');
                                throw new Error(errorText || 'Save failed');
                            }

                            statusEl.textContent = 'Saved successfully! Reloading...';
                            statusEl.style.color = 'green';

                            setTimeout(() => {
                                window.location.reload();
                            }, 1500);

                        } catch (err) {
                            console.error(err);
                            statusEl.textContent = 'Failed to save: ' + (err.message || 'Unknown error');
                            statusEl.style.color = 'red';
                            saveBtn.disabled = false;
                            saveBtn.textContent = 'Save Client Selection';
                        }
                    });
                }

                const saveUnderwriterBtn = container.querySelector('#save-underwriter-decision');
                const underwriterStatusEl = container.querySelector('#underwriter-decision-status');
                const underwriterCommentEl = container.querySelector('#underwriter-comment');

                if (saveUnderwriterBtn) {
                    saveUnderwriterBtn.addEventListener('click', async () => {
                        const approveCheckbox = container.querySelector('#underwriter-approve');
                        const comment = (underwriterCommentEl?.value || '').trim();

                        if (!comment) {
                            underwriterStatusEl.textContent = 'Please provide notes for the underwriter.';
                            underwriterStatusEl.style.color = 'red';
                            return;
                        }

                        const decision = approveCheckbox.checked ? 'uw_approved' : null;

                        if (!decision) {
                            underwriterStatusEl.textContent = 'Please check the checkbox to submit to underwriter.';
                            underwriterStatusEl.style.color = 'red';
                            return;
                        }

                        saveUnderwriterBtn.disabled = true;
                        saveUnderwriterBtn.textContent = 'Submitting...';
                        underwriterStatusEl.textContent = '';

                        try {
                            const resp = await fetch('/api/agent/update_status', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                                },
                                body: JSON.stringify({
                                    unique_id: uniqueId,
                                    actor: 'underwriter',
                                    status: decision,
                                    comment: comment,
                                })
                            });

                            if (!resp.ok) {
                                const errorText = await resp.text().catch(() => '');
                                throw new Error(errorText || 'Submission failed');
                            }
                            
                            underwriterStatusEl.textContent = 'Submitted successfully! Reloading...';
                            underwriterStatusEl.style.color = 'green';

                            setTimeout(() => {
                                window.location.reload();
                            });

                        } catch (err) {
                            console.error(err);
                            underwriterStatusEl.textContent = 'Failed to submit: ' + (err.message || 'Unknown error');
                            underwriterStatusEl.style.color = 'red';
                            saveUnderwriterBtn.disabled = false;
                            saveUnderwriterBtn.textContent = 'Submit';
                        }
                    });
                }
                const policyDecisionSelect = container.querySelector('#policy-decision-select');
                if (policyDecisionSelect) {
                    policyDecisionSelect.addEventListener('change', async function() {
                        const decision = policyDecisionSelect.value;
                        await handlePolicyDecision(uniqueId, decision);
                    });
                }

                // Add the event listener for the view policy summary button
                const viewSummaryBtn = container.querySelector('#view-policy-summary-btn');
                if (viewSummaryBtn) {
                    viewSummaryBtn.addEventListener('click', function() {
                        if (!uniqueId) {
                            alert('No Unique ID found. Please load an application first.');
                            return;
                        }
                        window.location.href = `/html/Policy_Creation.html?uid=${encodeURIComponent(uniqueId)}&view=summary`;
                    });
                }

            } catch (err) {
                console.error('Error rendering plans tab:', err);
                container.innerHTML = '<p style="color: red;">Failed to load plans. Please try again.</p>';
            }

        };

        /**
         * Handles the final policy decision (Created/Denied).
         * @param {string} uniqueId - The unique ID of the application.
         * @param {string} decision - 'policy_created' or 'policy_denied'.
         */
        async function handlePolicyDecision(uniqueId, decision) {
            const statusEl = document.getElementById('policy-decision-status');
            const selectEl = document.getElementById('policy-decision-select');
            const userRole = localStorage.getItem('userRole');
            if (!uniqueId || !decision) return;

            if (decision === 'policy_created') {
                // Policy Created option: Navigate to the policy creation page
                window.location.href = `/html/Policy_Creation.html?uid=${encodeURIComponent(uniqueId)}`;
                return;
            }

            if (decision === 'policy_denied') {
                // Policy Denied option: Update status and reload
                if (!confirm("Are you sure you want to mark this application as Policy Denied? This action cannot be undone.")) {
                    selectEl.value = ''; // Reset dropdown
                    return;
                }

                if (selectEl) {
                    selectEl.disabled = true;
                }
                statusEl.textContent = 'Processing denial...';
                statusEl.style.color = 'orange';

                try {
                    const resp = await fetch('/api/agent/update_status', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                        },
                        body: JSON.stringify({
                            unique_id: uniqueId,
                            actor: 'underwriter',
                            status: 'Policy_Denied', // Matches the desired final status
                            comment: 'Application denied at the final policy stage.',
                            application_status: 'Policy_Denied' // Ensure canonical status is set
                        })
                    });

                    if (!resp.ok) {
                        const errorText = await resp.text().catch(() => '');
                        throw new Error(errorText || 'Denial update failed');
                    }

                    statusEl.textContent = 'Policy Denied status set. Reloading...';
                    statusEl.style.color = 'green';
                    
                    // Reload the page to reflect the new status and lock the form
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);

                } catch (err) {
                    console.error(err);
                    statusEl.textContent = 'Failed to set denial status: ' + (err.message || 'Unknown error');
                    statusEl.style.color = 'red';
                    if (selectEl) selectEl.disabled = false;
                    selectEl.value = ''; // Reset dropdown
                }
            }
        }
        });
    </script>
</body>
</html>