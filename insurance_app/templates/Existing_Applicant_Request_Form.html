<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="stylesheet" href="/static/css/logo.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Existing Applicant Request Form</title>
    <link rel="icon" href="/static/img/icon.png" type="image/png">
    <link rel="stylesheet" href="../css/common.css">
    <link rel="stylesheet" href="../css/sidebar.css">
    <link rel="stylesheet" href="../css/health_history.css">
    <link rel="stylesheet" href="../css/members.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script defer src="{{ url_for('static', filename='js/plan_selection_summary_v2.js') }}"></script>
    <style>
        .loader-bar {
            display: flex;
            gap: .5rem;
            align-items: center;
            margin: 3rem 0;
        }

        .loader-bar input {
            max-width: 240px;
        }

        .supervisor-meta .loader-bar label {
            min-width: 160px;
        }

        #sup-status-input {
            max-width: 280px;
        }

        .comment-box {
            border: 1px solid #ccc;
            padding: 8px;
            min-height: 40px;
            background: #fff;
        }

        .form-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .last-modified-inline {
            margin-left: auto;
        }
    </style>
</head>

<body data-sidebar="existing-applicant">

    <div class="container">
        <header class="page-header">
            <link rel="stylesheet" href="/static/css/logo.css">
            <h1>Existing Applicant Request Form</h1>
        </header>
        <p id="page-description" style="margin: 2em 0; text-align: center;">Please enter a Unique ID below and select
            "Load." This will instantly retrieve the saved details, allowing you to review the policy request.</p>

        <div class="loader-bar" id="member-load">
            <label for="load-unique-id"><strong>Unique ID</strong></label>
            <input id="load-unique-id" type="text" placeholder="Enter Unique ID" />
            <button id="btn-load" class="btn btn-secondary" type="button">Load</button>
        </div>
        <form id="insurance-form">

            <p id="load-status" class="muted"></p>

            <section id="supervisor-meta" class="section supervisor-meta" style="display:none;">
                <div class="form-group" style="margin-top:8px;">
                    <div><strong>Status</strong></div>
                    <div id="sup-summary" class="comment-box" role="textbox" aria-readonly="true"
                        style="white-space:normal; font-family: inherit; font-size: inherit; line-height:1.2; min-height: 48px; padding:0; margin:0;">
                    </div>
                </div>
            </section>

            <div id="primary-contact-placeholder" class="section"></div>
            <div id="Health-History-placeholder" class="section"></div>
            <div id="members-covered-placeholder" class="section"></div>
            <div id="cover-cost-placeholder" class="section"></div>
            <div id="existing-coverage-placeholder" class="section"></div>
            <div id="claims-service-placeholder" class="section"></div>
            <div id="Finance-Documentation-placeholder" class="section"></div>
            <div id="comments-noted-placeholder" class="section"></div>
            <div id="one-pager-placeholder" class="section"></div>

            <div class="form-actions">
                <button type="button" id="preview-btn" class="btn">Proceed</button>
                <button type="reset" id="reset-btn" class="btn btn-secondary">Reset</button>
                <div id="last-modified-container" class="last-modified-inline"></div>
            </div>
        </form>
    </div>

    <script src="../js/sidebar.js"></script>
    <script src="../js/calculations.js"></script>
    <script src="../js/validation.js"></script>
    <script src="../js/member_management.js"></script>
    <script src="../js/disease_details.js"></script>
    <script src="../js/comments_noted.js"></script>
    <script src="../js/preview_tab.js"></script>
    <script src="../js/occupation_data.js"></script>
    <script src="../js/occupation_dropdown.js"></script>
    <script src="../js/progress_bar.js" defer></script>
    <script src="../js/existing_prefill.js"></script>
    <script src="../js/one_pager.js"></script>
    <script src="../js/existing_coverage.js" defer></script>
    <script src="../js/script.js" defer></script>
    <script src="../js/data_fetch.js" defer></script>

    <script>
        // Utility to escape HTML for safe rendering
        function escapeHtmlClient(text) {
            if (text === null || text === undefined) return '';
            return String(text)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&gt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function formatTimestampForDisplay(timestampStr) {
            if (!timestampStr) return '—';

            try {
                let dt = null;

                try {
                    dt = new Date(timestampStr.replace('Z', ''));
                    if (isNaN(dt.getTime())) dt = null;
                } catch (e) { }

                if (!dt && timestampStr.includes('_')) {
                    try {
                        const parts = timestampStr.split('_');
                        if (parts.length === 2) {
                            const datePart = parts[0];
                            const timePart = parts[1].replace(/-/g, ':');
                            dt = new Date(`${datePart}T${timePart}`);
                        }
                    } catch (e) { }
                }

                if (dt) {
                    return dt.toLocaleString('en-IN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true,
                        timeZone: 'Asia/Kolkata'
                    });
                }

                return timestampStr;
            } catch (e) {
                console.warn('Error formatting timestamp:', e);
                return timestampStr;
            }
        }

        const ROLE_STATUS = {
            OPEN_DRAFT: ['OPEN', ''],                 // OPEN or empty -> draft/open
            SUBMITTED: ['SUP_REVIEW'],                // submitted for review (supervisor reviewing)
            SUPERVISOR_REJECTED: ['SUP_REJECTED'],    // supervisor has rejected
            SUPERVISOR_APPROVED: ['SUP_APPROVED'],    // supervisor has approved, pending client
            CLIENT_APPROVED: ['client_approved'],     // client agreed
            WITH_UW: ['With_UW'],                     // underwriter stage
            POLICY_CREATED: ['Policy_Created', 'Policy created'] // normalize capitalization variants
        };

        // Normalize any incoming status value into a trimmed string
        function _normalize(s) {
            if (s === null || s === undefined) return '';
            return String(s).trim();
        }

        // Check if current user is the owner (agent) of the application
        function _isOwner(currentUserId, applicationAgent) {
            if (!currentUserId || !applicationAgent) return false;
            const currentLower = String(currentUserId).trim().toLowerCase();
            const agentLower = String(applicationAgent).trim().toLowerCase();
            // Check for exact match or partial match (user ID contained in agent field)
            return currentLower === agentLower ||
                agentLower.includes(currentLower) ||
                currentLower.includes(agentLower);
        }

        // Returns true if applicant details should be editable by the role at the given status
        // Now also considers ownership - agents can only edit their own applications
        function _isApplicantEditable(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);

            // AGENT: editable only when OPEN (i.e. before 'Submitted for Review') or when SUPERVISOR_REJECTED
            // AND must be the owner of the application
            if (roleL === 'agent') {
                const isOwner = _isOwner(currentUserId, applicationAgent);
                if (!isOwner) {
                    return false; // Agent cannot edit applications they don't own
                }
                if (ROLE_STATUS.OPEN_DRAFT.includes(status) || ROLE_STATUS.SUPERVISOR_REJECTED.includes(status)) {
                    return true;
                }
                return false;
            }

            // SUPERVISOR: editable ONLY during SUP_REVIEW (submitted for review)
            // Supervisors should NOT edit OPEN applications - those need to be submitted for review first by the agent
            if (roleL === 'supervisor') {
                if (ROLE_STATUS.SUBMITTED.includes(status)) return true;
                return false;
            }

            // Other roles (admin, superadmin) do not edit applicant details here
            return false;
        }

        // Returns true if agent should be allowed to select plans (SUP_APPROVED stage only)
        // Agents must also be the owner of the application
        function _canAgentSelectPlans(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);

            // Check if status allows plan selection
            const statusAllows = ROLE_STATUS.SUPERVISOR_APPROVED.includes(status);
            if (!statusAllows) return false;

            // Agents must own the application
            if (roleL === 'agent') {
                return _isOwner(currentUserId, applicationAgent);
            }

            // Supervisors can select plans for any application at this stage
            if (roleL === 'supervisor') {
                return true;
            }

            return false;
        }
        // Returns true if agent or supervisor can submit to UW (CLIENT_APPROVED stage only)
        // Agents must also be the owner of the application
        function _canSubmitToUnderwriter(role, statusStr, currentUserId, applicationAgent) {
            const roleL = (role || '').toLowerCase();
            const status = _normalize(statusStr);

            const statusAllows = ROLE_STATUS.CLIENT_APPROVED.includes(status);
            if (!statusAllows) return false;

            // Agents must own the application
            if (roleL === 'agent') {
                return _isOwner(currentUserId, applicationAgent);
            }

            // Supervisors can submit for any application
            if (roleL === 'supervisor') {
                return true;
            }

            return false;
        }

        /* DOM lock/unlock helpers (scoped to #insurance-form so page nav stays functional) */
        function _lockElement(el) {
            if (!el) return;
            const tag = (el.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea') {
                el.setAttribute('readonly', 'readonly');
            } else if (tag === 'select') {
                el.disabled = true;
            } else if (tag === 'button' || tag === 'a') {
                // mark disabled
                el.disabled = true;
                el.setAttribute('aria-disabled', 'true');
            }
            el.style.opacity = '0.6';
            el.style.cursor = 'not-allowed';
        }

        function _unlockElement(el) {
            if (!el) return;
            el.removeAttribute('readonly');
            el.disabled = false;
            el.removeAttribute('aria-disabled');
            el.style.opacity = '';
            el.style.cursor = '';
        }

        function _unlockEntireForm() {
            const form = document.getElementById('insurance-form');
            if (!form) return;
            form.querySelectorAll('input,select,textarea,button,a').forEach(_unlockElement);
        }

        function _lockFormExcept(exceptions = []) {
            const form = document.getElementById('insurance-form');
            if (!form) return;
            const controls = form.querySelectorAll('input,select,textarea,button,a');
            controls.forEach(el => {
                for (const ex of exceptions) {
                    if (!ex) continue;
                    if (typeof ex === 'string') {
                        try { if (el.matches && el.matches(ex)) return; } catch (e) { }
                    } else if (ex instanceof Element) {
                        if (ex.contains(el)) return;
                    }
                }
                _lockElement(el);
            });
        }

        /* Derive the canonical status for decision making from the submission data.
        Prefer application_status, then supervisor_approval_status, then underwriter_status, then client_status.
        */
        function deriveCanonicalStatusFromSubmission(data = {}) {
            if (!data || typeof data !== 'object') return '';
            const cand = [
                data.application_status,
                data.supervisor_approval_status,
                data.underwriter_status,
                data.client_status,
                data.final_status
            ];
            for (const v of cand) {
                if (v != null && String(v).trim()) return String(v).trim();
            }
            return '';
        }

        /**
         * Apply role+status restrictions.
         * role: string e.g., 'agent' | 'supervisor'
         * submissionData: the fetched submission object (may be {} on initial page load)
         * currentUserId: the logged-in user's ID
         */
        function applyRoleAndStatusRestrictions(role, submissionData, currentUserId) {
            // start from a clean slate
            _unlockEntireForm();

            const status = deriveCanonicalStatusFromSubmission(submissionData || {});
            const applicationAgent = submissionData?.agent || '';
            const isOwner = _isOwner(currentUserId, applicationAgent);
            const applicantEditable = _isApplicantEditable(role, status, currentUserId, applicationAgent);
            const agentCanSelectPlans = _canAgentSelectPlans(role, status, currentUserId, applicationAgent);
            const canSubmitToUW = _canSubmitToUnderwriter(role, status, currentUserId, applicationAgent);

            // If applicant details editable for this role — leave everything unlocked
            if (applicantEditable) {
                return;
            }

            // Build exceptions to don't lock the navigation; 
            const exceptions = ['.tab-button', '.tab-navigation', '.btn-next', '.btn-back', '.accordion-header', '.accordion-button', '#view-policy-doc-btn'];

            if (agentCanSelectPlans) {
                const plansPanel = document.getElementById('tab-panel-plans-selection');
                if (plansPanel) exceptions.push(plansPanel);
                const plansTabBtn = document.getElementById('tab-plans-selection');
                if (plansTabBtn) exceptions.push(plansTabBtn);
            }

            // perform the lock 
            _lockFormExcept(exceptions);

            // Hide reset/preview:
            ['reset-btn', 'preview-btn'].forEach(id => {
                const b = document.getElementById(id);
                if (b) {
                    b.classList.add('hidden');
                    b.disabled = true;
                }
            });

            if (ROLE_STATUS.WITH_UW.includes(status) && isOwner) {
                const policyDecision = document.getElementById('policy-decision-select');
                if (policyDecision) {
                    _unlockElement(policyDecision);
                }
            }

            if (ROLE_STATUS.POLICY_CREATED.includes(status)) {
                const viewBtn = document.getElementById('view-policy-summary-btn');
                if (viewBtn) {
                    _unlockElement(viewBtn);
                }
            }

            // If agent can select plans, ensure plan controls are explicitly unlocked
            if (agentCanSelectPlans) {
                const plansPanel = document.getElementById('tab-panel-plans-selection');
                if (plansPanel) {
                    const planControls = plansPanel.querySelectorAll('input[type="checkbox"], .plan-checkbox, .plan-select, input.plan-select');
                    planControls.forEach(_unlockElement);
                }
            }
            // If the user can submit to UW, ensure the UW controls are unlocked
            if (canSubmitToUW) {
                const uwSection = document.getElementById('underwriter-section');
                if (uwSection) {
                    const uwControls = uwSection.querySelectorAll(
                        '#underwriter-approve, #underwriter-comment, #save-underwriter-decision, #underwriter-branch'
                    );
                    uwControls.forEach(_unlockElement);

                }
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            // IMPORTANT: Clear any stale member data on page load
            // This prevents cross-form data contamination (e.g., members from New Applicant form appearing here)
            localStorage.removeItem('members');
            localStorage.removeItem('comments_noted');
            console.log('Existing Applicant form: Cleared stale data on page load');

            const statusEl = document.getElementById('load-status');
            const loadBtn = document.getElementById('btn-load');
            const idInput = document.getElementById('load-unique-id');
            const form = document.getElementById('insurance-form');
            const previewBtn = document.getElementById('preview-btn');
            const resetBtn = document.getElementById('reset-btn');

            function setActionButtonsEnabled(enabled) {
                if (previewBtn) previewBtn.disabled = !enabled;
                if (resetBtn) resetBtn.disabled = !enabled;
            }

            const userId = localStorage.getItem('loggedInUserId');

            if (!userId) {
                window.location.href = 'Main_login.html';
            }

            async function addPlansTab(uniqueId) {
                const tabNav = document.querySelector('.tab-navigation');
                const tabContentContainer = document.querySelector('.tab-content-container');

                if (!tabNav || !tabContentContainer) return;
                if (document.getElementById('tab-plans-selection')) return;

                const tabIndex = 8;

                const li = document.createElement('li');
                li.setAttribute('role', 'presentation');

                const button = document.createElement('button');
                button.className = 'tab-button';
                button.setAttribute('role', 'tab');
                button.setAttribute('aria-selected', 'false');
                button.setAttribute('aria-controls', 'tab-panel-plans-selection');
                button.setAttribute('id', 'tab-plans-selection');
                button.setAttribute('type', 'button');
                button.textContent = 'Plans';
                button.dataset.index = tabIndex;

                button.addEventListener('click', () => {
                    document.querySelectorAll('.tab-button').forEach((btn, i) => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-selected', 'false');
                    });
                    button.classList.add('active');
                    button.setAttribute('aria-selected', 'true');

                    document.querySelectorAll('.tab-content-wrapper').forEach(wrapper => {
                        wrapper.classList.remove('active');
                    });
                    const plansWrapper = document.getElementById('tab-panel-plans-selection');
                    if (plansWrapper) plansWrapper.classList.add('active');
                });

                li.appendChild(button);
                tabNav.appendChild(li);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'tab-content-wrapper';
                contentWrapper.setAttribute('role', 'tabpanel');
                contentWrapper.setAttribute('id', 'tab-panel-plans-selection');
                contentWrapper.setAttribute('aria-labelledby', 'tab-plans-selection');
                contentWrapper.dataset.index = tabIndex;

                const contentDiv = document.createElement('div');
                contentDiv.id = 'plans-selection-content';
                contentWrapper.appendChild(contentDiv);

                const navButtons = document.createElement('div');
                navButtons.className = 'tab-navigation-buttons';

                const backBtn = document.createElement('button');
                backBtn.type = 'button';
                backBtn.className = 'btn tab-nav-btn btn-back';
                backBtn.textContent = 'Back';
                backBtn.addEventListener('click', () => {
                    const commentsTab = document.getElementById('tab-comments-noted');
                    if (commentsTab) commentsTab.click();
                });

                navButtons.appendChild(backBtn);
                contentWrapper.appendChild(navButtons);

                tabContentContainer.appendChild(contentWrapper);

                if (typeof window.renderPlansTab === 'function') {
                    await window.renderPlansTab(contentDiv, uniqueId);
                }
            }

            async function addOnePagerTab(uniqueId) {
                const tabNav = document.querySelector('.tab-navigation');
                const tabContentContainer = document.querySelector('.tab-content-container');

                if (!tabNav || !tabContentContainer) return;
                if (document.getElementById('tab-one-pager')) return;

                const tabIndex = 9;

                const li = document.createElement('li');
                li.setAttribute('role', 'presentation');

                const button = document.createElement('button');
                button.className = 'tab-button';
                button.setAttribute('role', 'tab');
                button.setAttribute('aria-selected', 'false');
                button.setAttribute('aria-controls', 'tab-panel-one-pager');
                button.setAttribute('id', 'tab-one-pager');
                button.setAttribute('type', 'button');
                button.textContent = 'One Pager';
                button.dataset.index = tabIndex;

                button.addEventListener('click', () => {
                    document.querySelectorAll('.tab-button').forEach((btn) => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-selected', 'false');
                    });
                    button.classList.add('active');
                    button.setAttribute('aria-selected', 'true');

                    document.querySelectorAll('.tab-content-wrapper').forEach(wrapper => {
                        wrapper.classList.remove('active');
                    });
                    const wrapper = document.getElementById('tab-panel-one-pager');
                    if (wrapper) wrapper.classList.add('active');

                    const contentD = document.getElementById('one-pager-content');
                    if (contentD && typeof window.renderOnePager === 'function') {
                        window.renderOnePager(contentD, uniqueId);
                    }
                });

                li.appendChild(button);
                tabNav.appendChild(li);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'tab-content-wrapper';
                contentWrapper.setAttribute('role', 'tabpanel');
                contentWrapper.setAttribute('id', 'tab-panel-one-pager');
                contentWrapper.setAttribute('aria-labelledby', 'tab-one-pager');
                contentWrapper.dataset.index = tabIndex;

                const contentDiv = document.createElement('div');
                contentDiv.id = 'one-pager-content';
                contentWrapper.appendChild(contentDiv);

                const navButtons = document.createElement('div');
                navButtons.className = 'tab-navigation-buttons';
                const backBtn = document.createElement('button');
                backBtn.type = 'button';
                backBtn.className = 'btn tab-nav-btn btn-back';
                backBtn.textContent = 'Back';
                backBtn.addEventListener('click', () => {
                    const plansTab = document.getElementById('tab-plans-selection');
                    if (plansTab) plansTab.click();
                });
                navButtons.appendChild(backBtn);
                contentWrapper.appendChild(navButtons);

                tabContentContainer.appendChild(contentWrapper);

                try {
                    const resp = await fetch('One_Pager.html');
                    if (resp.ok) {
                        contentDiv.innerHTML = await resp.text();
                        if (typeof window.renderOnePager === 'function') {
                            await window.renderOnePager(contentDiv, uniqueId);
                        }
                    } else {
                        contentDiv.innerHTML = '<p class="error">Failed to load One Pager template.</p>';
                    }
                } catch (e) {
                    console.error("Error loading One Pager:", e);
                    contentDiv.innerHTML = '<p class="error">Error loading section.</p>';
                }
            }

            const userRole = localStorage.getItem('userRole');
            applyRoleAndStatusRestrictions(userRole, {}, userId); // no submission data yet; safe initial call


            function hardResetForm() {
                try {
                    localStorage.removeItem('members');
                    localStorage.removeItem('formSummary');
                    localStorage.removeItem('submissionData');
                    localStorage.removeItem('plans');
                    localStorage.removeItem('editMemberId');
                    localStorage.removeItem('comments_noted');
                    sessionStorage.removeItem('currentUniqueId');

                    if (form) {
                        form.reset();
                        const ctrls = form.querySelectorAll('input, select, textarea');
                        ctrls.forEach(el => {
                            const tag = (el.tagName || '').toLowerCase();
                            const type = (el.type || '').toLowerCase();
                            if (tag === 'input') {
                                if (type === 'checkbox' || type === 'radio') {
                                    el.checked = false;
                                } else {
                                    el.value = '';
                                }
                            } else if (tag === 'select') {
                                el.selectedIndex = 0;
                            } else if (tag === 'textarea') {
                                el.value = '';
                            }
                        });
                    }

                    try {
                        const membersList = document.getElementById('members-list');
                        if (membersList) membersList.innerHTML = '';
                        const summaryContent = document.getElementById('summary-content');
                        if (summaryContent) summaryContent.innerHTML = '<p class="placeholder-text">Hover over a member to see their details.</p>';
                        if (window.loadMembersGlobal) window.loadMembersGlobal();
                        if (window.updatePeopleCounter) window.updatePeopleCounter();
                    } catch (e) { }

                    try {
                        if (typeof window.clearCommentsSession === 'function') {
                            window.clearCommentsSession();
                        } else {
                            const tb = document.getElementById('comments-tbody');
                            if (tb) tb.innerHTML = '';
                            const tbl = document.getElementById('comments-table');
                            if (tbl) tbl.style.display = 'none';
                            const noMsg = document.getElementById('no-comments-message');
                            if (noMsg) noMsg.style.display = 'block';
                        }
                    } catch (e) { }

                    statusEl.textContent = '';
                    const supSummary = document.getElementById('sup-summary');
                    if (supSummary) supSummary.textContent = '';
                    const lastMod = document.getElementById('last-modified-footer');
                    if (lastMod) lastMod.style.display = 'none';

                    // Clear progress bar and its data
                    try {
                        window.currentSubmissionData = null;
                        localStorage.removeItem('currentUniqueId');
                        const progressBar = document.querySelector('.progress-bar-container');
                        if (progressBar) progressBar.remove();
                    } catch (e) { }

                    setActionButtonsEnabled(true);
                } catch (e) {
                    console.warn('Hard reset encountered an issue:', e);
                }
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', function (ev) {
                    ev.preventDefault();
                    hardResetForm();
                });
            }

            function attachOrCreateLastModifiedFooter() {
                const host = document.getElementById('last-modified-container');
                if (!host) return;
                let footer = document.getElementById('last-modified-footer');
                if (!footer) {
                    footer = document.createElement('div');
                    footer.id = 'last-modified-footer';
                    footer.className = 'last-modified-footer';
                    footer.style.display = 'none';
                    footer.innerHTML = 'Last Modified by <span id="last-modified-by">—</span> on <span id="last-modified-date">—</span>';
                } else if (footer.parentElement !== host) {
                    footer.parentElement.removeChild(footer);
                }
                host.appendChild(footer);
            }

            function updateMainLastModified(data) {
                attachOrCreateLastModifiedFooter();
                const footer = document.getElementById('last-modified-footer');
                const lastModifiedBy = document.getElementById('last-modified-by');
                const lastModifiedDate = document.getElementById('last-modified-date');
                if (!footer || !lastModifiedBy || !lastModifiedDate) return;

                let modifiedBy = '—';
                let modifiedAt = null;

                const timestampSources = [
                    { by: data.application_modified_by, at: data.application_modified_at, source: 'final' },
                    { by: data.underwriter_modified_by, at: data.underwriter_modified_at, source: 'underwriter' },
                    { by: data.supervisor_modified_by, at: data.supervisor_modified_at, source: 'supervisor' },
                    { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at, source: 'policy' },
                    { by: data.close_status_modified_by, at: data.close_status_modified_at, source: 'application' },
                    { by: data.first_created_by, at: data.first_created_at, source: 'created' }
                ];

                const validTimestamps = timestampSources
                    .filter(ts => ts.by && ts.at)
                    .sort((a, b) => {
                        try {
                            const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                            const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                            return dateB - dateA;
                        } catch (e) {
                            return 0;
                        }
                    });

                if (validTimestamps.length > 0) {
                    const latest = validTimestamps[0];
                    modifiedBy = latest.by;
                    modifiedAt = latest.at;
                }

                let formattedDate = '—';
                if (modifiedAt) {
                    formattedDate = formatTimestampForDisplay(modifiedAt);
                }

                lastModifiedBy.textContent = modifiedBy;
                lastModifiedDate.textContent = formattedDate;
                footer.style.display = 'block';
            }

            function updateWorkflowButtons(applicationStatus, userRole) {
                const status = (applicationStatus || '').trim();
                console.log("Workflow Button Status:", status, "Role:", userRole);

                // Use querySelector to ensure elements are rtrieved when they're in the plans tab
                const policyDecisionSelect = document.getElementById('policy-decision-select');
                const policyDecisionLabel = document.getElementById('policy-decision-label');
                const viewSummaryBtn = document.getElementById('view-policy-summary-btn');

                // Hide/disable everything by default
                if (policyDecisionSelect) {
                    policyDecisionSelect.style.display = 'none';
                    policyDecisionSelect.disabled = true;
                }
                if (policyDecisionLabel) {
                    policyDecisionLabel.style.display = 'none';
                }
                if (viewSummaryBtn) {
                    viewSummaryBtn.style.display = 'none';
                }

                const normalizedStatus = (applicationStatus || '').toUpperCase().trim();

                // Show the dropdown when the status is 'With_UW'
                const showDecisionDropdown = normalizedStatus === 'WITH_UW';
                // Show the view summary button when the status is 'Policy_Created' or 'Policy_Denied'
                const showViewSummaryButton = normalizedStatus === 'POLICY_CREATED' || normalizedStatus === 'POLICY_DENIED';

                if (policyDecisionSelect && showDecisionDropdown) {
                    policyDecisionSelect.style.display = 'inline-block';
                    policyDecisionSelect.disabled = false;
                }

                if (policyDecisionLabel && showDecisionDropdown) {
                    policyDecisionLabel.style.display = 'inline-block';
                }

                if (viewSummaryBtn && showViewSummaryButton) {
                    viewSummaryBtn.style.display = 'inline-block';
                }
            }

            async function loadById(uniqueId) {
                const uid = (uniqueId || '').trim();
                statusEl.textContent = '';
                if (!uid) { statusEl.textContent = 'Please enter Unique ID.'; return; }

                // IMPORTANT: Clear previous applicant's data before loading new one
                // This prevents cross-applicant data contamination
                localStorage.removeItem('members');
                localStorage.removeItem('comments_noted');
                localStorage.removeItem('formSummary');
                // Clear UI as well
                if (window.loadMembersGlobal) {
                    try { window.loadMembersGlobal(); } catch(e) {}
                }
                console.log('Cleared previous applicant data before loading:', uid);

                const allControls = document.querySelectorAll('input, select, textarea');
                allControls.forEach(el => {
                    el.removeAttribute('readonly');
                    el.disabled = false;
                    el.style.cursor = '';
                    el.style.opacity = '';
                    el.style.backgroundColor = '';
                });

                try {
                    const resp = await fetch(`/api/agent/submission/${encodeURIComponent(uid)}`);
                    if (!resp.ok) { statusEl.textContent = 'Submission not found.'; return; }
                    const data = await resp.json();
                    console.log('Raw data from API:', data);
                    let formPayload = null;
                    try {
                        if (typeof data.form_summary === 'string') {
                            formPayload = JSON.parse(data.form_summary);
                        } else if (data.form_summary && typeof data.form_summary === 'object') {
                            formPayload = data.form_summary;
                        }
                    } catch (e) { formPayload = null; }
                    console.log('Parsed formPayload:', formPayload)
                    if (!formPayload) {
                        try {
                            const legacy = await fetch(`/submission/${encodeURIComponent(uid)}`);
                            if (legacy.ok) {
                                formPayload = await legacy.json();
                            }
                        } catch (e) { }
                    }

                    if (!formPayload) formPayload = data;
                    console.log('Final formPayload being sent to prefill:', formPayload);
                    if (window.prefillExistingForm) {
                        await window.prefillExistingForm(formPayload);
                        statusEl.textContent = 'Data loaded. You can edit and save.';
                    } else {
                        statusEl.textContent = 'Prefill function not available.';
                    }
                    if (window.initializeDiseaseDetails) {
                        setTimeout(() => {
                            window.initializeDiseaseDetails();
                        }, 500);
                    }

                    localStorage.setItem('currentUniqueId', uid);
                    if (window.initializeCommentsNoted) {
                        window.initializeCommentsNoted();
                    }
                    if (window.loadExistingComments) {
                        window.loadExistingComments(uid);
                    }

                    updateMainLastModified(data);

                    const supSection = document.getElementById('supervisor-meta');
                    const supSummary = document.getElementById('sup-summary');
                    if (supSection) supSection.style.display = '';
                    if (supSummary) supSummary.textContent = 'Loading status...';

                    // Use an async IIFE to properly handle the progress bar update
                    (async () => {
                        const statusDisp = (data.final_status && String(data.final_status).trim())
                            ? data.final_status
                            : (data.application_status || data.supervisor_approval_status || 'Open');

                        console.log("DEBUGGING: About to update progress bar with", statusDisp);

                        // Store submission data globally for progress bar to access timestamps
                        window.currentSubmissionData = data;

                        // Helper function to wait for progress bar script to load
                        const waitForProgressBar = (maxWaitMs = 5000) => {
                            return new Promise((resolve) => {
                                if (typeof window.updateProgressBar === 'function') {
                                    resolve(true);
                                    return;
                                }
                                const startTime = Date.now();
                                const checkInterval = setInterval(() => {
                                    if (typeof window.updateProgressBar === 'function') {
                                        clearInterval(checkInterval);
                                        resolve(true);
                                    } else if (Date.now() - startTime >= maxWaitMs) {
                                        clearInterval(checkInterval);
                                        console.warn("Progress bar script did not load in time");
                                        resolve(false);
                                    }
                                }, 50);
                            });
                        };

                        // Wait for progress bar to be available, then update it
                        const progressBarReady = await waitForProgressBar();
                        if (progressBarReady) {
                            // Use application_status as primary, fall back to supervisor_approval_status
                            const progressStatus = data.application_status || data.supervisor_approval_status || 'OPEN';
                            try {
                                await window.updateProgressBar(progressStatus);
                                console.log("Progress bar updated successfully with status:", progressStatus);
                            } catch (err) {
                                console.error("Error updating progress bar:", err);
                            }
                        }

                        const comments = (data.application_comments && String(data.application_comments).trim()) ? data.application_comments : 'No notes';
                        let tsStr = '—';
                        let by = '—';
                        const timestampSources = [
                            { by: data.application_modified_by, at: data.application_modified_at },
                            { by: data.underwriter_modified_by, at: data.underwriter_modified_at },
                            { by: data.supervisor_modified_by, at: data.supervisor_modified_at },
                            { by: data.policy_outcome_modified_by, at: data.policy_outcome_modified_at },
                            { by: data.close_status_modified_by, at: data.close_status_modified_at },
                            { by: data.agent, at: data.timestamp },
                            { by: data.first_created_by, at: data.first_created_at }
                        ];

                        const validTimestamps = timestampSources
                            .filter(ts => ts.by && ts.at)
                            .sort((a, b) => {
                                try {
                                    const dateA = new Date(a.at.includes('_') ? a.at.replace('_', 'T').replace(/-/g, ':') : a.at);
                                    const dateB = new Date(b.at.includes('_') ? b.at.replace('_', 'T').replace(/-/g, ':') : b.at);
                                    return dateB - dateA;
                                } catch (e) {
                                    return 0;
                                }
                            });

                        if (validTimestamps.length > 0) {
                            const latest = validTimestamps[0];
                            by = latest.by;
                            tsStr = formatTimestampForDisplay(latest.at);
                        }

                        const summaryHtml = `<strong>Application Status:</strong> ${statusDisp}<br>
                                            <strong>Notes:</strong> ${comments}<br>
                                            <strong>Last Updated by:</strong> ${by} <strong>Last Updated at:</strong> ${tsStr}`;
                        if (supSummary) supSummary.innerHTML = summaryHtml;

                    })();

                    if (!data.final_status) {
                        try {
                            const metaResp = await fetch(`/submission/${encodeURIComponent(uid)}/meta`);
                            if (metaResp.ok) {
                                const meta = await metaResp.json();
                                if (supSummary) {
                                    const raw = (meta.supervisor_status || '').toString();
                                    const normalized = raw.trim().toUpperCase();
                                    const statusDisp = normalized === 'OPEN' ? 'Open' : (raw || 'Open');
                                    const comments = (meta.supervisor_comments && String(meta.supervisor_comments).trim()) ? meta.supervisor_comments : 'No notes';
                                    let tsStr = '—';
                                    if (meta.supervisor_modified_at) {
                                        tsStr = formatTimestampForDisplay(meta.supervisor_modified_at);
                                    }
                                    const by = meta.supervisor_modified_by || '—';
                                    const summaryHtml = '<strong>Application Status:</strong> ' + statusDisp + '<br>' +
                                        '<strong>Supervisor Notes:</strong> ' + comments + '<br>' +
                                        '<strong>Last Updated by:</strong> ' + by + ' <strong>Last Updated at:</strong> ' + tsStr;
                                    supSummary.innerHTML = summaryHtml;

                                    const norm = String(statusDisp || '').trim().toUpperCase();
                                    const allowed = (norm === 'OPEN' || norm === 'SUP_REJECTED');
                                    setActionButtonsEnabled(allowed);
                                }
                            }
                        } catch (e) {
                            console.warn('Failed to fetch supervisor meta', e);
                        }
                    }

                    const statusForTab = (data.final_status || data.supervisor_approval_status || '').toUpperCase();
                    if (statusForTab === 'SUP_APPROVED') {
                        await addPlansTab(uid);
                        await addOnePagerTab(uid);
                    }

                    const userRole = localStorage.getItem('userRole');
                    updateWorkflowButtons(data.application_status, userRole);
                    if (userRole) {
                        applyRoleAndStatusRestrictions(userRole, data, userId);
                    }


                } catch (e) {
                    console.error(e);
                    statusEl.textContent = 'Failed to load data.';
                }
            }

            loadBtn.addEventListener('click', async function () {
                await loadById(idInput.value);
            });

            (async function autoLoadFromUrl() {
                const urlParams = new URLSearchParams(window.location.search);
                const uidFromUrl = urlParams.get('uid');
                if (uidFromUrl) {
                    console.log('Auto-loading from URL parameter:', uidFromUrl);
                    // Set the input field value so user sees what's being loaded
                    if (idInput) {
                        idInput.value = uidFromUrl;
                    }
                    // Wait a bit for sections to load before calling loadById
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await loadById(uidFromUrl);
                }
            })();

            if (previewBtn) {
                previewBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    e.stopImmediatePropagation();

                    // Trigger form submission which will run all validation
                    const submitEvent = new Event('submit', {
                        bubbles: true,
                        cancelable: true
                    });
                    form.dispatchEvent(submitEvent);
                });
            }


            form.addEventListener('submit', async function (e) {
                e.preventDefault();

                if (previewBtn) {
                    previewBtn.disabled = true;
                    previewBtn.textContent = "Submitting...";
                }
                if (resetBtn) resetBtn.disabled = true;

                try {
                    // Disease duration validation for primary applicant (Since Year or Since Years)
                    const healthHistoryContent = document.getElementById('health-history-content');
                    if (healthHistoryContent) {
                        const diseaseEntries = healthHistoryContent.querySelectorAll('.disease-entry');
                        const diseaseErrors = [];

                        diseaseEntries.forEach(entry => {
                            const checkbox = entry.querySelector('input[type="checkbox"][name="disease"], input[type="checkbox"]');
                            const sinceYearSelect = entry.querySelector('.disease-since-year');
                            const sinceYearsInput = entry.querySelector('.disease-since-years');
                            const errorSpan = entry.querySelector('.error-message');

                            if (!checkbox) return;

                            // Clear any previous error state
                            if (errorSpan) {
                                errorSpan.textContent = '';
                                errorSpan.style.display = 'none';
                            }
                            if (sinceYearSelect) sinceYearSelect.classList.remove('input-error');
                            if (sinceYearsInput) sinceYearsInput.classList.remove('input-error');

                            // Only validate if disease is selected
                            if (checkbox.checked) {
                                // Check if at least one of year or years is filled
                                const hasYear = sinceYearSelect && sinceYearSelect.value && sinceYearSelect.value !== '';
                                const hasYears = sinceYearsInput && sinceYearsInput.value && sinceYearsInput.value !== '' && parseInt(sinceYearsInput.value) >= 0;

                                if (!hasYear && !hasYears) {
                                    const headerLabel = entry.querySelector('.disease-header label');
                                    const diseaseLabel = headerLabel ? headerLabel.textContent.trim() : 'the selected disease';
                                    diseaseErrors.push(`Disease duration for ${diseaseLabel} is required (Since Year or Since Years)`);
                                    if (errorSpan) {
                                        errorSpan.textContent = 'Please enter Since Year or Since Years';
                                        errorSpan.style.display = 'block';
                                    }
                                    if (sinceYearSelect) sinceYearSelect.classList.add('input-error');
                                    if (sinceYearsInput) sinceYearsInput.classList.add('input-error');
                                }
                            }
                        });

                        // If there are disease duration errors, stop submission
                        if (diseaseErrors.length > 0) {
                            alert('Please fix the following errors before submitting:\n\n• ' + diseaseErrors.join('\n• '));

                            if (previewBtn) {
                                previewBtn.textContent = "Proceed";
                                previewBtn.disabled = false;
                            }
                            if (resetBtn) resetBtn.disabled = false;

                            // Scroll to first error
                            const firstError = healthHistoryContent.querySelector('.input-error');
                            if (firstError) {
                                firstError.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                setTimeout(() => firstError.focus(), 300);
                            }

                            return false;
                        }
                    }

                    const uniqueId = (idInput?.value || '').trim();

                    const formObj = {};
                    const allInputs = form.querySelectorAll('input, select, textarea');

                    // Get reference to members section to identify inputs we should skip
                    const membersCoveredContent = document.getElementById('members-covered-content');

                    allInputs.forEach(el => {
                        if (!el.name) return;
                        if (el.disabled) return; // skip disabled/read-only fields entirely

                        if (membersCoveredContent && membersCoveredContent.contains(el)) {
                            // This input is inside the members section
                            // Member data is handled separately via localStorage 'members'
                            return;
                        }

                        // Also skip inputs inside any .member-form container
                        if (el.closest('.member-form') || el.closest('.member-tab-content')) {
                            return;
                        }

                        const k = el.name;
                        const v = el.value;

                        if (el.type === 'radio') {
                            if (el.checked) formObj[k] = v;
                        } else if (el.type === 'checkbox') {
                            if (!formObj[k]) formObj[k] = [];
                            if (el.checked) formObj[k].push(v);
                        } else {
                            if (k in formObj) {
                                const cur = formObj[k];
                                if (Array.isArray(cur)) cur.push(v);
                                else formObj[k] = [cur, v];
                            } else {
                                formObj[k] = v;
                            }
                        }
                    });


                    if (!formObj.unique_id) {
                        if (uniqueId) formObj.unique_id = uniqueId;
                    }

                    if (!formObj.applicant_name) {
                        let foundName = '';
                        const trySelectors = [
                            '[name="applicant_name"]', '#applicant_name',
                            '[name$="applicant_name"]', '[name*="applicant"][name*="name"]',
                            'input[placeholder*="Full Name" i]'
                        ];
                        for (const sel of trySelectors) {
                            const el = form.querySelector(sel);
                            if (el && el.value && String(el.value).trim()) {
                                foundName = String(el.value).trim();
                                break;
                            }
                        }
                        if (foundName) formObj.applicant_name = foundName;
                    }

                    if (!formObj.unique_id || !formObj.applicant_name) {
                        throw new Error('Missing required fields: Unique ID and Applicant Name.');
                    }

                    try {
                        if (typeof window.getCommentsData === 'function') {
                            const c = window.getCommentsData();
                            if (c && typeof c === 'object') formObj.comments_noted = c.comments_noted;
                        }
                    } catch { }

                    // ====================================================================
                    // CRITICAL: Include members in formObj for server submission
                    // Members are stored separately in localStorage but MUST be sent to server
                    // ====================================================================
                    try {
                        const membersData = JSON.parse(localStorage.getItem('members')) || [];
                        if (membersData.length > 0) {
                            formObj.members = membersData;
                            console.log('Including', membersData.length, 'member(s) in submission');
                        }
                    } catch (e) {
                        console.warn('Error reading members from localStorage:', e);
                    }

                    const userId = localStorage.getItem('loggedInUserId');
                    if (!userId) {
                        throw new Error('User not logged in. Please log in and try again.');
                    }

                    const payload = {
                        userId: userId,
                        formData: formObj
                    };
                    if (window.clearProgressTimestamps) {
                        window.clearProgressTimestamps(formObj.unique_id);
                    }

                    const resp = await fetch('/submit', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-User-Id': userId
                        },
                        body: JSON.stringify(payload)
                    });

                    if (!resp.ok) {
                        let errorMessage = 'Please check your connection and try again.';
                        try {
                            const errorData = await resp.json();
                            errorMessage = errorData.error || errorData.message || errorMessage;
                        } catch (e) {
                            const txt = await resp.text().catch(() => '');
                            errorMessage = txt || `Server error (${resp.status})`;
                        }
                        throw new Error(errorMessage);
                    }

                    const result = await resp.json().catch(() => ({}));

                    const summaryData = {
                        primaryContact: {},
                        healthHistory: {},
                        members: JSON.parse(localStorage.getItem('members')) || [],
                        coverAndCost: {},
                        existingCoverage: {},
                        claimsAndService: {},
                        financeAndDocumentation: {},
                        commentsNoted: window.getCommentsData ? window.getCommentsData() : { comments_noted: [] }
                    };

                    // Prefer the same section-based logic used by the New Applicant flow
                    if (typeof window.getSectionData === 'function') {
                        // Primary Contact
                        summaryData.primaryContact = window.getSectionData('primary-contact') || {};
                        summaryData.primaryContact['unique_id'] = formObj.unique_id;

                        // Health History
                        summaryData.healthHistory = window.getSectionData('health-history') || {};

                        // Other sections
                        summaryData.coverAndCost = window.getSectionData('cover-cost') || {};
                        summaryData.existingCoverage = window.getSectionData('existing-coverage') || {};
                        summaryData.claimsAndService = window.getSectionData('claims-service') || {};
                        summaryData.financeAndDocumentation = window.getSectionData('finance-documentation') || {};
                    } else {
                        // Fallback: legacy mapping if getSectionData is not available
                        summaryData.primaryContact['unique_id'] = formObj.unique_id;

                        Object.keys(formObj).forEach(key => {
                            const value = formObj[key];

                            if (key === 'unique_id') return;

                            if ([
                                'applicant_name', 'gender', 'email', 'phone', 'address',
                                'self-dob', 'self-height', 'self-weight', 'self-age',
                                'occupation', 'city', 'hubs'
                            ].includes(key)) {
                                summaryData.primaryContact[key] = value;
                            }
                            else if (
                                key.startsWith('medical-') || key.startsWith('medical_') ||
                                key.startsWith('disease-') || key.startsWith('disease_') ||
                                key === 'self-details' || key === 'self_details' ||
                                key === 'disease' || key.endsWith('_details') || key.endsWith('_start_date') ||
                                key.endsWith('_since_year') || key.endsWith('_since_years')
                            ) {
                                summaryData.healthHistory[key] = value;
                            }
                            else if ([
                                'policy-type', 'sum-insured', 'annual-budget', 'payment-mode',
                                'room-preference', 'co-pay', 'ncb-importance', 'maternity-cover',
                                'opd-cover', 'top-up'
                            ].includes(key)) {
                                summaryData.coverAndCost[key] = value;
                            }
                            else if ([
                                'existing-policies', 'port-policy', 'critical-illness', 'worldwide-cover',
                                'policy-type-category', 'insurer-name', 'existing-policy-number',
                                'existing-sum-insured', 'policy-since-date'
                            ].includes(key)) {
                                summaryData.existingCoverage[key] = value;
                            }
                            else if ([
                                'past-claims', 'claim-issues', 'service-expectations',
                                'network-hospital-1st', 'network-hospital-2nd', 'network-hospital-3rd'
                            ].includes(key)) {
                                summaryData.claimsAndService[key] = value;
                            }
                            else if (['tax-benefit', 'address_proof_details', 'gst-number'].includes(key)) {
                                summaryData.financeAndDocumentation[key] = value;
                            }
                        });
                    }


                    localStorage.setItem('formSummary', JSON.stringify(summaryData));
                    localStorage.setItem('submissionData', JSON.stringify(formObj));
                    if (result.plans) {
                        localStorage.setItem('plans', JSON.stringify(result.plans));
                    }

                    if (previewBtn) {
                        previewBtn.textContent = 'Submitted Successfully!';
                        previewBtn.style.backgroundColor = '#28a745';
                    }

                    alert('Form submitted successfully!\n\nSubmission ID: ' + (result.submissionId || formObj.unique_id));

                    window.location.href = `Summary.html?unique_id=${encodeURIComponent(formObj.unique_id)}`;

                } catch (err) {
                    console.error(err);
                    let errorMessage = err.message || 'Failed to submit. Please review required fields.';

                    if (err.name === 'TypeError' && err.message.includes('fetch')) {
                        errorMessage = 'Network connection failed. Please check your internet connection.';
                    }

                    alert(`Submission failed: ${errorMessage}`);

                    statusEl.textContent = `Submission failed: ${errorMessage}`;
                    statusEl.style.color = 'red';
                    if (previewBtn) {
                        previewBtn.textContent = "Submit";
                        previewBtn.style.backgroundColor = '';
                        previewBtn.disabled = false;
                    }
                    if (resetBtn) resetBtn.disabled = false;
                }
            });

            // Render supervisor approved inputs (readonly)
            async function renderSupervisorApprovedInputs(host, uid) {
                try {
                    let submissionData = {};
                    try {
                        const r = await fetch(`/api/agent/submission/${encodeURIComponent(uid)}`);
                        if (r.ok) submissionData = await r.json();
                    } catch (e) { console.warn('Could not fetch submission:', e); }

                    let formSummary = {};
                    if (typeof submissionData.form_summary === 'string') {
                        try { formSummary = JSON.parse(submissionData.form_summary); } catch (e) { }
                    } else if (typeof submissionData.form_summary === 'object') {
                        formSummary = submissionData.form_summary;
                    }

                    const planMeta = formSummary.plan_meta || {};
                    console.log('DEBUG: Loaded planMeta from form_summary:', planMeta);

                    // Get supervisor selected plans from plan_summary endpoint (which has supervisor_selected list)
                    let supervisorMetadata = {};
                    let proposed = {};
                    try {
                        const planSummaryResp = await fetch(`/plan_summary/${encodeURIComponent(uid)}`);
                        if (planSummaryResp.ok) {
                            const planSummaryData = await planSummaryResp.json();
                            proposed = planSummaryData.proposed || {};
                            console.log('DEBUG: Loaded proposed structure from plan_summary:', proposed);

                            // Load supervisor metadata if available
                            try {
                                const metaResp = await fetch(`/supervisor_plan_metadata/${encodeURIComponent(uid)}`);
                                if (metaResp.ok) {
                                    const metaData = await metaResp.json();
                                    supervisorMetadata = metaData.supervisor_meta || {};
                                    console.log('DEBUG: Loaded supervisorMetadata from /supervisor_plan_metadata:', supervisorMetadata);
                                }
                            } catch (e) { console.warn('Could not load supervisor metadata:', e); }
                        }
                    } catch (e) { console.warn('Could not load plan summary:', e); }

                    // Get supervisor selected list - try multiple sources
                    let supSelectedPlans = [];
                    try {
                        const planSummaryResp = await fetch(`/plan_summary/${encodeURIComponent(uid)}`);
                        if (planSummaryResp.ok) {
                            const ps = await planSummaryResp.json();
                            supSelectedPlans = ps.supervisor_selected || [];
                            console.log('DEBUG: Loaded supervisor_selected from plan_summary:', supSelectedPlans);
                        }
                    } catch (e) { console.warn('Could not load plan summary:', e); }
                    if (!Array.isArray(supSelectedPlans)) supSelectedPlans = [];

                    const comprehensivePlans = [];
                    const individualPlans = [];

                    try {
                        supSelectedPlans.forEach(planName => {
                            try {
                                const meta = planMeta[planName] || {};
                                // Get agent metadata first (contains memberName)
                                const agentInputs = meta.agent || {};
                                // Get supervisor metadata for values (premium, sum_insured, policy_term)
                                const supervisorInputs = supervisorMetadata[planName] || meta.supervisor || {};

                                // Try to get memberName from:
                                // 1. Agent metadata (but ignore if it's the internal 'comprehensive_cover' marker)
                                // 2. Supervisor metadata (but ignore if it's the internal 'comprehensive_cover' marker)
                                // 3. Proposed structure (find which member has this plan)
                                let memberName = agentInputs.memberName || supervisorInputs.memberName || '';

                                // DEFENSIVE: Never allow 'comprehensive_cover' to be classified as an individual member
                                if (String(memberName).toLowerCase() === 'comprehensive_cover') {
                                    console.log(`DEFENSIVE: Clearing memberName='comprehensive_cover' for plan "${planName}" (internal marker, not individual)`);
                                    memberName = '';
                                }

                                if (!memberName) {
                                    // Search in proposed structure for which member has this plan
                                    for (const key in proposed) {
                                        // Skip comprehensive_cover on first pass
                                        if (key === 'comprehensive_cover') continue;

                                        const member = proposed[key];
                                        if (member && member.plans && Array.isArray(member.plans)) {
                                            if (member.plans.includes(planName)) {
                                                // Found the member, use their name
                                                memberName = member.name || key;
                                                break;
                                            }
                                        }
                                    }
                                }

                                console.log(`DEBUG: Processing supervisor plan "${planName}":`, {
                                    agentInputs,
                                    supervisorInputs,
                                    memberName,
                                    proposedStructure: proposed
                                });

                                // Only add to individual if it has a member name
                                if (memberName && String(memberName).trim()) {
                                    individualPlans.push({
                                        planName,
                                        premium: supervisorInputs.premium || '',
                                        sumInsured: supervisorInputs.sum_insured || '',
                                        policyTerm: supervisorInputs.policy_term || '',
                                        memberName: memberName
                                    });
                                } else {
                                    // Add to comprehensive only if there's no member name
                                    comprehensivePlans.push({
                                        planName,
                                        premium: supervisorInputs.premium || '',
                                        sumInsured: supervisorInputs.sum_insured || '',
                                        policyTerm: supervisorInputs.policy_term || ''
                                    });
                                }
                            } catch (itemError) {
                                console.error(`Error processing plan "${planName}":`, itemError);
                            }
                        });
                    } catch (loopError) {
                        console.error('Error in forEach loop:', loopError);
                        throw loopError;
                    }

                    let html = '';

                    // Comprehensive Plans
                    if (comprehensivePlans.length > 0) {
                        html += '<div style="margin: 16px 0; min-width: 0; overflow: hidden;">';
                        html += '<h4 style="margin: 8px 0; font-size: 0.95rem; letter-spacing: 0.2px; font-weight: 700; color: #2c3e50; background-color: #cff9ff; padding: 10px 15px; border-radius: 6px; display: inline-block;">Comprehensive Selected Plans</h4>';
                        html += '<div style="display: grid; grid-template-columns: 1fr 100px 120px 120px; column-gap: 16px; align-items: center; padding: 10px 6px; font-weight: 600; border-bottom: 1px solid #e2e6ea; background: transparent; margin-bottom: 8px; min-width: 0;">';
                        html += '<div>Plans</div><div>Premium</div><div>Sum Insured</div><div>Policy Term</div></div>';

                        comprehensivePlans.forEach(plan => {
                            html += `<div style="padding: 10px 6px; border-radius: 6px; background: #fff; margin-bottom: 8px; display: grid; grid-template-columns: 1fr 100px 120px 120px; column-gap: 16px; align-items: center; border: 1px solid #eee; min-width: 0;">
                            <div style="font-weight: 400; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtmlClient(plan.planName)}">${escapeHtmlClient(plan.planName)}</div>
                            <input type="text" value="${escapeHtmlClient(plan.premium)}" readonly style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: #f5f7f8 !important; color: #666;">
                            <input type="text" value="${escapeHtmlClient(plan.sumInsured)}" readonly style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: #f5f7f8 !important; color: #666;">
                            <select disabled style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; background: #f5f7f8; color: #666;">
                                <option selected>${escapeHtmlClient(plan.policyTerm || 'N/A')}</option>
                            </select>
                        </div>`;
                        });
                        html += '</div>';
                    }

                    // Individual Plans
                    if (individualPlans.length > 0) {
                        html += '<div style="margin: 16px 0; min-width: 0; overflow: hidden;">';
                        html += '<h4 style="margin: 8px 0; font-size: 0.95rem; letter-spacing: 0.2px; font-weight: 700; color: #2c3e50; background-color: #cff9ff; padding: 10px 15px; border-radius: 6px; display: inline-block;">Individual Selected Plans</h4>';
                        html += '<div style="display: grid; grid-template-columns: 1fr 100px 120px 120px; column-gap: 16px; align-items: center; padding: 10px 6px; font-weight: 600; border-bottom: 1px solid #e2e6ea; background: transparent; margin-bottom: 8px; min-width: 0;">';
                        html += '<div>Plans</div><div>Premium</div><div>Sum Insured</div><div>Policy Term</div></div>';

                        individualPlans.forEach(plan => {
                            const memberPlanLabel = (plan.memberName ? (plan.memberName + ' — ') : '') + plan.planName;
                            html += `<div style="padding: 10px 6px; border-radius: 6px; background: #fff; margin-bottom: 8px; display: grid; grid-template-columns: 1fr 100px 120px 120px; column-gap: 16px; align-items: center; border: 1px solid #eee; min-width: 0;">
                            <div style="font-weight: 400; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtmlClient(memberPlanLabel)}">${escapeHtmlClient(memberPlanLabel)}</div>
                            <input type="text" value="${escapeHtmlClient(plan.premium)}" readonly style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: #f5f7f8 !important; color: #666;">
                            <input type="text" value="${escapeHtmlClient(plan.sumInsured)}" readonly style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: #f5f7f8 !important; color: #666;">
                            <select disabled style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; background: #f5f7f8; color: #666;">
                                <option selected>${escapeHtmlClient(plan.policyTerm || 'N/A')}</option>
                            </select>
                        </div>`;
                        });
                        html += '</div>';
                    }

                    if (comprehensivePlans.length === 0 && individualPlans.length === 0) {
                        html = '<p style="color: #888; font-style: italic;">No supervisor approved plans available.</p>';
                    }

                    host.innerHTML = html;
                } catch (e) {
                    console.error('CRITICAL ERROR in renderSupervisorApprovedInputs:', e);
                    console.error('Error message:', e.message);
                    console.error('Error stack:', e.stack);
                    host.innerHTML = '<p style="color: #b91c1c;">Error loading supervisor approved inputs: ' + e.message + '</p>';
                }
            }

            // Render client agreed inputs (editable)
            async function renderClientAgreedInputs(host, uid, proposedPlans, clientSelected, clientStatus) {
                try {
                    // Determine if we should show read-only view
                    const status = (clientStatus || '').toLowerCase();
                    const isReadOnly = status === 'client_approved' || status === 'with_uw' || status === 'policy_created' || status === 'policy_denied';

                    let submissionData = {};
                    try {
                        const r = await fetch(`/api/agent/submission/${encodeURIComponent(uid)}`);
                        if (r.ok) submissionData = await r.json();
                    } catch (e) { console.warn('Could not fetch submission:', e); }

                    let formSummary = {};
                    if (typeof submissionData.form_summary === 'string') {
                        try { formSummary = JSON.parse(submissionData.form_summary); } catch (e) { }
                    } else if (typeof submissionData.form_summary === 'object') {
                        formSummary = submissionData.form_summary;
                    }

                    const planMeta = formSummary.plan_meta || {};
                    const clientSelectedList = Array.from(clientSelected || []);

                    // Load proposed structure for member lookups
                    let proposed = {};
                    try {
                        const planSummaryResp = await fetch(`/plan_summary/${encodeURIComponent(uid)}`);
                        if (planSummaryResp.ok) {
                            const planSummaryData = await planSummaryResp.json();
                            proposed = planSummaryData.proposed || {};
                        }
                    } catch (e) { console.warn('Could not load proposed structure:', e); }

                    const comprehensivePlans = [];
                    const individualPlans = [];

                    clientSelectedList.forEach(planName => {
                        const trimmedPlanName = String(planName || '').trim();

                        // Try to find metadata entry - try exact match first, then trimmed versions
                        let meta = planMeta[trimmedPlanName] || planMeta[planName];
                        if (!meta) {
                            // Try to find by trimming all keys
                            for (const key in planMeta) {
                                if (String(key).trim() === trimmedPlanName) {
                                    meta = planMeta[key];
                                    break;
                                }
                            }
                        }
                        meta = meta || {};

                        const agentInputs = meta.agent || {};
                        const supervisorInputs = meta.supervisor || {};
                        const clientInputs = meta.client || {};

                        // Try to get memberName from:
                        // 1. Agent metadata
                        // 2. Client metadata
                        // 3. Supervisor metadata
                        // 4. Proposed structure (find which member has this plan)
                        let memberName = (agentInputs.memberName || '').trim() || (clientInputs.memberName || '').trim() || (supervisorInputs.memberName || '').trim() || '';

                        if (!memberName) {
                            // Search in proposed structure for which member has this plan
                            for (const key in proposed) {
                                // SKIP comprehensive_cover - those are family/comprehensive plans
                                if (key === 'comprehensive_cover') {
                                    continue;
                                }

                                const member = proposed[key];
                                if (member && member.plans && Array.isArray(member.plans)) {
                                    const foundExact = member.plans.includes(trimmedPlanName);
                                    const foundTrimmed = !foundExact && member.plans.some(p => String(p).trim() === trimmedPlanName);
                                    if (foundExact || foundTrimmed) {
                                        // Found the member, use their name
                                        memberName = member.name || key;
                                        break;
                                    }
                                }
                            }
                        }

                        // CRITICAL: Only add to individual if it has a member name
                        if (memberName && String(memberName).trim()) {
                            individualPlans.push({
                                planName: trimmedPlanName,
                                // CRITICAL: Show client value if available, otherwise ONLY supervisor value (NOT agent)
                                // This ensures only supervisor-approved values are shown as defaults
                                premium: clientInputs.premium || supervisorInputs.premium || '',
                                sumInsured: clientInputs.sum_insured || supervisorInputs.sum_insured || '',
                                policyTerm: clientInputs.policy_term || supervisorInputs.policy_term || '',
                                memberName: memberName
                            });
                        } else {
                            // Add to comprehensive only if there's no member name
                            comprehensivePlans.push({
                                planName: trimmedPlanName,
                                // CRITICAL: Show client value if available, otherwise ONLY supervisor value (NOT agent)
                                // This ensures only supervisor-approved values are shown as defaults
                                premium: clientInputs.premium || supervisorInputs.premium || '',
                                sumInsured: clientInputs.sum_insured || supervisorInputs.sum_insured || '',
                                policyTerm: clientInputs.policy_term || supervisorInputs.policy_term || ''
                            });
                        }
                    });

                    let html = '';

                    // Comprehensive Plans
                    if (comprehensivePlans.length > 0) {
                        html += '<div style="margin: 16px 0; min-width: 0; overflow: hidden;">';
                        html += '<h4 style="margin: 8px 0; font-size: 0.95rem; letter-spacing: 0.2px; font-weight: 700; color: #2c3e50; background-color: #cff9ff; padding: 10px 15px; border-radius: 6px; display: inline-block;">Comprehensive Selected Plans</h4>';
                        html += '<div style="display: grid; grid-template-columns: 1fr 100px 120px 120px 50px; column-gap: 16px; align-items: center; padding: 10px 6px; font-weight: 600; border-bottom: 1px solid #e2e6ea; background: transparent; margin-bottom: 8px; min-width: 0;">';
                        html += '<div>Plans</div><div>Premium <span style="color: #ef4444;">*</span></div><div>Sum Insured <span style="color: #ef4444;">*</span></div><div>Policy Term <span style="color: #ef4444;">*</span></div><div></div></div>';

                        comprehensivePlans.forEach((plan, idx) => {
                            const termOptions = ['1 Year', '2 Years', '3 Years', '4 Years', '5 Years'];
                            let termOptionsHtml = '';
                            const policyTerm = plan.policyTerm || '';
                            termOptions.forEach(opt => {
                                const isSelected = (policyTerm === opt || (policyTerm && policyTerm.includes(opt.split(' ')[0]))) ? 'selected' : '';
                                termOptionsHtml += `<option ${isSelected}>${opt}</option>`;
                            });

                            const inputReadonly = isReadOnly ? 'readonly' : '';
                            const inputBg = isReadOnly ? '#f5f7f8 !important' : '#fff';
                            const inputColor = isReadOnly ? '#666' : '#000';
                            const selectDisabled = isReadOnly ? 'disabled' : '';
                            const selectBg = isReadOnly ? '#f5f7f8' : '#fff';
                            const selectColor = isReadOnly ? '#666' : '#000';
                            const deleteBtn = isReadOnly ? '' : `<button type="button" class="delete-client-plan" style="padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">−</button>`;

                            html += `<div style="padding: 10px 6px; border-radius: 6px; background: #fff; margin-bottom: 8px; display: grid; grid-template-columns: 1fr 100px 120px 120px 50px; column-gap: 16px; align-items: center; border: 1px solid #eee; min-width: 0;" class="client-plan-row" data-plan="${escapeHtmlClient(plan.planName)}">
                            <div style="font-weight: 400; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtmlClient(plan.planName)}">${escapeHtmlClient(plan.planName)}</div>
                            <input type="text" placeholder="Premium" value="${escapeHtmlClient(plan.premium)}" ${inputReadonly} class="client-premium-input" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: ${inputBg}; color: ${inputColor};">
                            <input type="text" placeholder="Sum Insured" value="${escapeHtmlClient(plan.sumInsured)}" ${inputReadonly} class="client-sumins-input" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: ${inputBg}; color: ${inputColor};">
                            <select class="client-term-select" ${selectDisabled} style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; background: ${selectBg}; color: ${selectColor};">${termOptionsHtml}</select>
                            ${deleteBtn}
                        </div>`;
                        });
                        html += '</div>';
                    }

                    // Individual Plans
                    if (individualPlans.length > 0) {
                        html += '<div style="margin: 16px 0; min-width: 0; overflow: hidden;">';
                        html += '<h4 style="margin: 8px 0; font-size: 0.95rem; letter-spacing: 0.2px; font-weight: 700; color: #2c3e50; background-color: #cff9ff; padding: 10px 15px; border-radius: 6px; display: inline-block;">Individual Selected Plans</h4>';
                        html += '<div style="display: grid; grid-template-columns: 1fr 100px 120px 120px 50px; column-gap: 16px; align-items: center; padding: 10px 6px; font-weight: 600; border-bottom: 1px solid #e2e6ea; background: transparent; margin-bottom: 8px; min-width: 0;">';
                        html += '<div>Plans</div><div>Premium <span style="color: #ef4444;">*</span></div><div>Sum Insured <span style="color: #ef4444;">*</span></div><div>Policy Term <span style="color: #ef4444;">*</span></div><div></div></div>';

                        individualPlans.forEach((plan, idx) => {
                            const memberPlanLabel = (plan.memberName ? (plan.memberName + ' — ') : '') + plan.planName;
                            const termOptions = ['1 Year', '2 Years', '3 Years', '4 Years', '5 Years'];
                            let termOptionsHtml = '';
                            const policyTerm = plan.policyTerm || '';
                            termOptions.forEach(opt => {
                                const isSelected = (policyTerm === opt || (policyTerm && policyTerm.includes(opt.split(' ')[0]))) ? 'selected' : '';
                                termOptionsHtml += `<option ${isSelected}>${opt}</option>`;
                            });

                            const inputReadonly = isReadOnly ? 'readonly' : '';
                            const inputBg = isReadOnly ? '#f5f7f8 !important' : '#fff';
                            const inputColor = isReadOnly ? '#666' : '#000';
                            const selectDisabled = isReadOnly ? 'disabled' : '';
                            const selectBg = isReadOnly ? '#f5f7f8' : '#fff';
                            const selectColor = isReadOnly ? '#666' : '#000';
                            const deleteBtn = isReadOnly ? '' : `<button type="button" class="delete-client-plan" style="padding: 4px 8px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">−</button>`;

                            html += `<div style="padding: 10px 6px; border-radius: 6px; background: #fff; margin-bottom: 8px; display: grid; grid-template-columns: 1fr 100px 120px 120px 50px; column-gap: 16px; align-items: center; border: 1px solid #eee; min-width: 0;" class="client-plan-row" data-plan="${escapeHtmlClient(plan.planName)}" data-member="${escapeHtmlClient(plan.memberName)}">
                            <div style="font-weight: 400; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtmlClient(memberPlanLabel)}">${escapeHtmlClient(memberPlanLabel)}</div>
                            <input type="text" placeholder="Premium" value="${escapeHtmlClient(plan.premium)}" ${inputReadonly} class="client-premium-input" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: ${inputBg}; color: ${inputColor};">
                            <input type="text" placeholder="Sum Insured" value="${escapeHtmlClient(plan.sumInsured)}" ${inputReadonly} class="client-sumins-input" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; box-sizing: border-box; background: ${inputBg}; color: ${inputColor};">
                            <select class="client-term-select" ${selectDisabled} style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #d1d5d8; background: ${selectBg}; color: ${selectColor};">${termOptionsHtml}</select>
                            ${deleteBtn}
                        </div>`;
                        });
                        html += '</div>';
                    }

                    if (comprehensivePlans.length === 0 && individualPlans.length === 0) {
                        html = '<p style="color: #888; font-style: italic;">Select plans from the matrix above to add them here.</p>';
                    }

                    host.innerHTML = html;

                    // Attach delete event listeners
                    host.querySelectorAll('.delete-client-plan').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            e.preventDefault();
                            const planRow = btn.closest('.client-plan-row');
                            const planName = planRow.getAttribute('data-plan');

                            planRow.remove();
                            clientSelected.delete(planName);

                            // Uncheck matrix checkbox
                            const matrixHost = document.getElementById('plans-selection-matrix');
                            if (matrixHost) {
                                const checkbox = matrixHost.querySelector(`input[data-plan-name="${planName}"]`);
                                if (checkbox) {
                                    checkbox.checked = false;
                                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                            }

                            try {
                                await fetch(`/plan_summary/${encodeURIComponent(uid)}/client`, {
                                    method: 'PATCH',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ client_agreed: Array.from(clientSelected) })
                                });
                            } catch (e) { console.error('Failed to update client plans:', e); }
                        });
                    });
                } catch (e) {
                    host.innerHTML = '<p style="color: #b91c1c;">Error loading client agreed inputs.</p>';
                    console.error(e);
                }
            }

            window.renderPlansTab = async function (container, uniqueId) {
                if (!container || !uniqueId) return;

                container.innerHTML = '<p>Loading plans...</p>';

                try {
                    let planSummaryData = null;
                    try {
                        const resp = await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}`);
                        if (resp.ok) planSummaryData = await resp.json();
                    } catch (e) {
                        console.warn('Could not load from plan_summary endpoint:', e);
                    }

                    if (!planSummaryData || !planSummaryData.proposed || Object.keys(planSummaryData.proposed).length === 0) {
                        try {
                            const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                            if (submissionResp.ok) {
                                const submissionData = await submissionResp.json();
                                let proposedPlans = submissionData.proposed_plans;
                                if (proposedPlans && typeof proposedPlans === 'string') {
                                    proposedPlans = JSON.parse(proposedPlans);
                                }
                                if (proposedPlans && Object.keys(proposedPlans).length > 0) {
                                    await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/init_or_update`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ proposed: proposedPlans })
                                    });
                                    const resp2 = await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}`);
                                    if (resp2.ok) planSummaryData = await resp2.json();
                                }
                            }
                        } catch (e) {
                            console.error('Error initializing plan_summary from submission:', e);
                        }
                    }

                    let agentSelected = [];
                    if (planSummaryData?.agent_selected) {
                        agentSelected = Array.isArray(planSummaryData.agent_selected) ? planSummaryData.agent_selected : [];
                    }
                    if (agentSelected.length === 0) {
                        try {
                            const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                            if (submissionResp.ok) {
                                const submissionData = await submissionResp.json();
                                const possibleFields = ['agent_selected_plans', 'Agent_Selected_Plans', 'chosen_plans', 'plans_chosen'];
                                for (const field of possibleFields) {
                                    if (submissionData[field]) {
                                        try {
                                            const parsed = typeof submissionData[field] === 'string'
                                                ? JSON.parse(submissionData[field])
                                                : submissionData[field];
                                            if (Array.isArray(parsed) && parsed.length > 0) {
                                                agentSelected = parsed;
                                                break;
                                            }
                                        } catch (e) { }
                                    }
                                }
                                if (agentSelected.length > 0) {
                                    try {
                                        await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/agent`, {
                                            method: 'PATCH',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ agent_selected: agentSelected })
                                        });
                                    } catch (e) {
                                        console.error('Failed to sync agent selections:', e);
                                    }
                                }
                            }
                        } catch (e) {
                            console.error('Error loading agent selections from submission:', e);
                        }
                    }

                    const proposed = planSummaryData?.proposed || {};
                    const agentSel = new Set(agentSelected);
                    const supervisorSel = new Set(planSummaryData?.supervisor_selected || []);
                    const clientSel = new Set(planSummaryData?.client_agreed || []);

                    let submissionData = {};
                    try {
                        const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                        if (submissionResp.ok) submissionData = await submissionResp.json();
                    } catch (e) {
                        console.warn('Could not load submission data for status check:', e);
                    }

                    const clientStatus = (submissionData.client_status || '').toLowerCase();
                    const underwriterStatus = (submissionData.underwriter_status || '').toLowerCase();
                    const showUnderwriterSection = clientStatus === 'client_approved';

                    container.innerHTML = `
                    <div style="padding: 1rem;">
                        <h2>Plan Selection</h2>
                        <p>Review the plans selected by the agent and supervisor, then select the plans you agree to.</p>
                        <div id="plans-selection-matrix" style="margin-top: 1rem;"></div>
                        
                        <div class="accordion" style="margin-top: 2rem; border-radius: 0.5rem; border: 1px solid #e5e7eb;">
                            <div class="accordion-item">
                                <button type="button" class="accordion-header" style="width: 100%; text-align: left; padding: 0.75rem 1rem; background-color: #f9fafb; border: none; font-size: 0.95rem; font-weight: 700; color: #111827; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                                    Supervisor Approved Terms
                                    <span style="font-weight: 700; color: #6b7280;">+</span>
                                </button>
                                <div class="accordion-content" style="max-height: 0; overflow: hidden; transition: max-height 0.25s ease; background-color: #ffffff;">
                                    <div id="supervisor-approved-inputs-host" style="padding: 0.75rem 1rem 1rem;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="accordion" style="margin-top: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb;">
                            <div class="accordion-item">
                                <button type="button" class="accordion-header" style="width: 100%; text-align: left; padding: 0.75rem 1rem; background-color: #f9fafb; border: none; font-size: 0.95rem; font-weight: 700; color: #111827; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                                    Client Agreed Terms
                                    <span style="font-weight: 700; color: #6b7280;">+</span>
                                </button>
                                <div class="accordion-content" style="max-height: 0; overflow: hidden; transition: max-height 0.25s ease; background-color: #ffffff;">
                                    <div id="client-agreed-inputs-host" style="padding: 0.75rem 1rem 1rem;"></div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 1rem;">
                            <textarea id="client-plans-comment" rows="3" style="width: 100%; margin-bottom: 0.5rem;" placeholder="Add your notes about the selected plans"></textarea>
                        </div>
                        <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                            <button type="button" id="save-client-plans" class="btn">Save Client Selection</button>
                            <span id="client-plans-status" style="margin-left: 1rem;"></span>
                        </div>

                        <div id="underwriter-section" style="display: ${showUnderwriterSection ? 'block' : 'none'}; border-top: 2px solid #eee; padding-top: 1.5rem;">
                            <h3 style="margin-bottom: 0.5rem;">Underwriter Submission Review</h3>
                            <p style="color: #666; font-size: 0.9rem; margin-bottom: 1rem;">
                                Review the client's agreed plans and submit to underwriter.
                            </p>

                            <div style="background: #f9f9f9; padding: 1rem; border-radius: 6px; margin-bottom: 1rem;">
                                <strong style="display: block; margin-bottom: 0.5rem;">Client Agreed Plans:</strong>
                                <div id="client-agreed-display" style="margin-left: 1rem;">
                                    ${Array.from(clientSel).length > 0
                            ? Array.from(clientSel).map(p => `<div style="margin-bottom: 0.25rem;">• ${p}</div>`).join('')
                            : '<em style="color: #888;">No plans selected by client yet</em>'
                        }
                                </div>
                                ${submissionData.client_comments ? `
                                    <div style="margin-top: 0.75rem;">
                                        <strong style="display: block; margin-bottom: 0.25rem;">Client Notes:</strong>
                                        <div style="margin-left: 1rem; color: #555;">${submissionData.client_comments}</div>
                                    </div>
                                ` : ''}
                            </div>

                            <div style="margin-top: 1rem;">
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                        <input type="checkbox" id="underwriter-approve" checked>
                                        <span style="color: #007bff; font-weight: 600;">Submit to Underwriter</span>
                                    </label>
                                </div>

                                <label for="underwriter-comment" style="display: block; font-weight: 600; margin-bottom: 0.5rem;">
                                    Notes
                                </label>
                                <textarea id="underwriter-comment" rows="3" 
                                        style="width: 100%; margin-bottom: 0.5rem; padding: 0.5rem; border: 1px solid #ccc; border-radius: 4px;" 
                                        placeholder="Enter underwriter notes">${submissionData.underwriter_comments || ''}</textarea>

                                <div style="margin-top: 0.4rem; display:flex; align-items:center; gap:8px;">
                                    <label for="underwriter-branch" style="font-weight:600; margin-right:8px;">Underwriting Branch:</label>
                                    <select id="underwriter-branch" name="underwriter_branch" style="max-width: 240px; padding:6px;">
                                        <option value="" disabled selected>Select branch</option>
                                        <option value="Kukatpally">Kukatpally</option>
                                        <option value="Nalgonda">Nalgonda</option>
                                    </select>
                                    <span id="underwriter-branch-status" style="margin-left:8px;color:#d9534f;display:none;">Please select a branch</span>
                                </div>

                                <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; align-items: center;">
                                    <button type="button" id="save-underwriter-decision" class="btn">Submit</button>
                                    <span id="underwriter-decision-status" style="margin-left: 1rem;"></span>
                                </div>
                            </div>
                        </div>
                        <div class="workflow-actions" style="margin-top: 2rem; border-top: 2px solid #eee; padding-top: 1.5rem; display: flex; gap: 10px; align-items: center;">
                            <label for="policy-decision-select" id="policy-decision-label" style="font-weight: 600;">Final Policy Decision:</label>
                            <select id="policy-decision-select" class="form-control" style="max-width: 200px;" disabled>
                                <option value="" disabled selected>Select an action</option>
                                <option value="policy_created">Policy Created</option>
                                <option value="policy_denied">Policy Denied</option>
                            </select>
                            <span id="policy-decision-status" style="margin-left: 10px;"></span>

                            <button type="button" id="view-policy-summary-btn" class="btn" style="display: none; background-color: #10b981;">
                                <i class="fas fa-file-alt" style="margin-right: 6px;"></i>
                                View Policy Summary
                            </button>
                        </div>
                    </div>
                `;

                    // Setup accordion event listeners
                    const accordionHeaders = container.querySelectorAll('.accordion-header');
                    accordionHeaders.forEach(header => {
                        header.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();

                            const content = header.nextElementSibling;
                            const span = header.querySelector('span');
                            const isCurrentlyOpen = content.style.maxHeight && content.style.maxHeight !== '0px';

                            if (isCurrentlyOpen) {
                                // Collapsing
                                content.style.maxHeight = '0px';
                                if (span) span.textContent = '+';
                                header.style.backgroundColor = '#f9fafb';
                            } else {
                                // Expanding - use setTimeout to ensure DOM is ready
                                setTimeout(() => {
                                    content.style.maxHeight = (content.scrollHeight + 20) + 'px';
                                }, 0);
                                if (span) span.textContent = '−';
                                header.style.backgroundColor = '#eff6ff';
                            }
                        });
                    });

                    const matrixHost = container.querySelector('#plans-selection-matrix');
                    const commentEl = container.querySelector('#client-plans-comment');
                    const saveBtn = container.querySelector('#save-client-plans');
                    const statusEl = container.querySelector('#client-plans-status');

                    if (typeof window.renderPlanSelectionSummary === 'function') {
                        window.renderPlanSelectionSummary(matrixHost, {
                            proposed,
                            agentSel,
                            supervisorSel,
                            clientSel,
                            mode: 'approvals',
                            onClientToggle: async (planName, checked) => {
                                if (checked) clientSel.add(planName);
                                else clientSel.delete(planName);

                                try {
                                    await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/client`, {
                                        method: 'PATCH',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ client_agreed: Array.from(clientSel) })
                                    });
                                } catch (e) {
                                    console.error('Failed to save client selection:', e);
                                }

                                // Re-render client agreed inputs when matrix selection changes
                                try {
                                    const clientHost = container.querySelector('#client-agreed-inputs-host');
                                    if (clientHost) {
                                        await renderClientAgreedInputs(clientHost, uniqueId, proposed, clientSel, clientStatus);
                                    }
                                } catch (e) { console.warn('Could not re-render client inputs:', e); }
                            }
                        });
                    }

                    // Render Supervisor Approved Inputs (readonly)
                    try {
                        const supHost = container.querySelector('#supervisor-approved-inputs-host');
                        if (supHost) {
                            await renderSupervisorApprovedInputs(supHost, uniqueId);
                        }
                    } catch (e) { console.warn('Could not render supervisor approved inputs:', e); }

                    // Render Client Agreed Inputs (editable)
                    try {
                        const clientHost = container.querySelector('#client-agreed-inputs-host');
                        if (clientHost) {
                            await renderClientAgreedInputs(clientHost, uniqueId, proposed, clientSel, clientStatus);
                        }
                    } catch (e) { console.warn('Could not render client agreed inputs:', e); }

                    // Pre-fill saved client selections if they exist
                    try {
                        const submissionResp = await fetch(`/api/agent/submission/${encodeURIComponent(uniqueId)}`);
                        if (submissionResp.ok) {
                            const submissionData = await submissionResp.json();

                            if (submissionData.client_comments) {
                                commentEl.value = submissionData.client_comments;
                            }

                            if (submissionData.Client_Agreed_Plans) {
                                try {
                                    const savedPlans = JSON.parse(submissionData.Client_Agreed_Plans);
                                    if (Array.isArray(savedPlans) && savedPlans.length > 0) {
                                        savedPlans.forEach(planName => {
                                            clientSel.add(planName);
                                            const checkbox = matrixHost.querySelector(`input.pss-client[data-plan-name="${planName}"]`);
                                            if (checkbox) checkbox.checked = true;
                                        });
                                    }
                                } catch (e) {
                                    console.error('Error parsing saved plans:', e);
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error loading existing selections:', e);
                    }

                    // Client save handler - never lock, always allow re-doing
                    if (saveBtn) {
                        saveBtn.addEventListener('click', async () => {
                            const selected = Array.from(clientSel);
                            const comment = (commentEl?.value || '').trim();

                            if (selected.length === 0) {
                                statusEl.textContent = 'Please select at least one plan.';
                                statusEl.style.color = 'red';
                                return;
                            }

                            // Validate that all required fields are filled
                            const clientHost = container.querySelector('#client-agreed-inputs-host');
                            if (clientHost) {
                                const planRows = clientHost.querySelectorAll('.client-plan-row');
                                let allFieldsFilled = true;
                                let emptyFieldPlan = null;

                                planRows.forEach(row => {
                                    const planName = row.getAttribute('data-plan');
                                    const premium = (row.querySelector('.client-premium-input')?.value || '').trim();
                                    const sumInsured = (row.querySelector('.client-sumins-input')?.value || '').trim();
                                    const policyTerm = (row.querySelector('.client-term-select')?.value || '').trim();

                                    if (!premium || !sumInsured || !policyTerm) {
                                        allFieldsFilled = false;
                                        if (!emptyFieldPlan) {
                                            emptyFieldPlan = planName;
                                        }
                                    }
                                });

                                if (!allFieldsFilled) {
                                    statusEl.textContent = `Please fill in all required fields (Premium, Sum Insured, Policy Term) for all plans. Missing fields in: ${emptyFieldPlan}`;
                                    statusEl.style.color = 'red';
                                    return;
                                }
                            }

                            // Collect client input values from the editable section
                            const clientMeta = {};
                            try {
                                const clientHost = container.querySelector('#client-agreed-inputs-host');
                                if (clientHost) {
                                    const planRows = clientHost.querySelectorAll('.client-plan-row');
                                    planRows.forEach(row => {
                                        const planName = row.getAttribute('data-plan');
                                        const premium = row.querySelector('.client-premium-input')?.value || '';
                                        const sumInsured = row.querySelector('.client-sumins-input')?.value || '';
                                        const policyTerm = row.querySelector('.client-term-select')?.value || '';
                                        const memberName = row.getAttribute('data-member') || '';

                                        clientMeta[planName] = {
                                            premium,
                                            sum_insured: sumInsured,
                                            policy_term: policyTerm,
                                            memberName
                                        };
                                    });
                                }
                            } catch (e) { console.warn('Could not collect client inputs:', e); }

                            saveBtn.disabled = true;
                            saveBtn.textContent = 'Saving...';
                            statusEl.textContent = '';

                            try {
                                // Save client inputs to plan_summary endpoint
                                if (Object.keys(clientMeta).length > 0) {
                                    await fetch(`/plan_summary/${encodeURIComponent(uniqueId)}/client_meta`, {
                                        method: 'PATCH',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ client_meta: clientMeta })
                                    }).catch(e => console.warn('Could not save client meta:', e));
                                }

                                const resp = await fetch('/api/agent/update_status', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                                    },
                                    body: JSON.stringify({
                                        unique_id: uniqueId,
                                        actor: 'client',
                                        client_review: true,
                                        status: 'client_reviewed',
                                        comment: comment || 'Client agreed to selected plans',
                                        client_agreed_plans: selected,
                                        client_status: 'client_approved'
                                    })
                                });

                                if (!resp.ok) {
                                    const errorText = await resp.text().catch(() => '');
                                    throw new Error(errorText || 'Save failed');
                                }

                                statusEl.textContent = 'Saved successfully! Reloading...';
                                statusEl.style.color = 'green';

                                setTimeout(() => {
                                    window.location.reload();
                                }, 1500);

                            } catch (err) {
                                console.error(err);
                                statusEl.textContent = 'Failed to save: ' + (err.message || 'Unknown error');
                                statusEl.style.color = 'red';
                                saveBtn.disabled = false;
                                saveBtn.textContent = 'Save Client Selection';
                            }
                        });
                    }

                    const saveUnderwriterBtn = container.querySelector('#save-underwriter-decision');
                    const underwriterStatusEl = container.querySelector('#underwriter-decision-status');
                    const underwriterCommentEl = container.querySelector('#underwriter-comment');
                    const underwriterBranchSelect = container.querySelector('#underwriter-branch');
                    const underwriterBranchStatus = container.querySelector('#underwriter-branch-status');

                    if (saveUnderwriterBtn) {
                        saveUnderwriterBtn.addEventListener('click', async () => {
                            const approveCheckbox = container.querySelector('#underwriter-approve');
                            const comment = (underwriterCommentEl?.value || '').trim();
                            const branch = (underwriterBranchSelect?.value || '').trim();

                            if (!comment) {
                                underwriterStatusEl.textContent = 'Please provide notes for the underwriter.';
                                underwriterStatusEl.style.color = 'red';
                                return;
                            }

                            if (!branch) {
                                if (underwriterBranchStatus) underwriterBranchStatus.style.display = 'inline';
                                underwriterStatusEl.textContent = 'Please select an underwriting branch.';
                                underwriterStatusEl.style.color = 'red';
                                return;
                            } else {
                                if (underwriterBranchStatus) underwriterBranchStatus.style.display = 'none';
                            }

                            const decision = approveCheckbox.checked ? 'uw_approved' : null;

                            if (!decision) {
                                underwriterStatusEl.textContent = 'Please check the checkbox to submit to underwriter.';
                                underwriterStatusEl.style.color = 'red';
                                return;
                            }

                            saveUnderwriterBtn.disabled = true;
                            saveUnderwriterBtn.textContent = 'Submitting...';
                            underwriterStatusEl.textContent = '';

                            try {
                                const resp = await fetch('/api/agent/update_status', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                                    },
                                    body: JSON.stringify({
                                        unique_id: uniqueId,
                                        actor: 'underwriter',
                                        status: decision,
                                        comment: comment,
                                        underwriter_branch: branch,
                                    })
                                });

                                if (!resp.ok) {
                                    const errorText = await resp.text().catch(() => '');
                                    throw new Error(errorText || 'Submission failed');
                                }

                                underwriterStatusEl.textContent = 'Submitted successfully! Reloading...';
                                underwriterStatusEl.style.color = 'green';

                                // Immediately reflect submitted state: lock UI to show branch and controls disabled
                                try {
                                    if (underwriterBranchSelect) underwriterBranchSelect.disabled = true;
                                    if (underwriterCommentEl) underwriterCommentEl.disabled = true;
                                    const approveCheckbox = container.querySelector('#underwriter-approve');
                                    if (approveCheckbox) approveCheckbox.disabled = true;
                                    saveUnderwriterBtn.textContent = 'Submitted';
                                    saveUnderwriterBtn.disabled = true;
                                } catch (e) { }

                                setTimeout(() => {
                                    window.location.reload();
                                });

                            } catch (err) {
                                console.error(err);
                                underwriterStatusEl.textContent = 'Failed to submit: ' + (err.message || 'Unknown error');
                                underwriterStatusEl.style.color = 'red';
                                saveUnderwriterBtn.disabled = false;
                                saveUnderwriterBtn.textContent = 'Submit';
                            }
                        });
                    }
                    // Preselect Underwriter Branch if provided in submission data
                    try {
                        if (underwriterBranchSelect && submissionData.underwriter_branch) {
                            const desired = String(submissionData.underwriter_branch || '').trim().toLowerCase();
                            let setVal = '';
                            for (const opt of underwriterBranchSelect.options) {
                                if (String(opt.value || '').trim().toLowerCase() === desired) { setVal = opt.value; break; }
                            }
                            if (setVal) underwriterBranchSelect.value = setVal;
                        }
                        // If underwriter status exists (already submitted), disable the controls and mark as submitted
                        if (underwriterStatus) {
                            if (underwriterBranchSelect) underwriterBranchSelect.disabled = true;
                            if (underwriterCommentEl) underwriterCommentEl.disabled = true;
                            const approveCheckbox = container.querySelector('#underwriter-approve');
                            if (approveCheckbox) approveCheckbox.disabled = true;
                            if (saveUnderwriterBtn) {
                                saveUnderwriterBtn.disabled = true;
                                saveUnderwriterBtn.textContent = 'Submitted';
                            }
                        }
                    } catch (e) { }

                    const policyDecisionSelect = container.querySelector('#policy-decision-select');
                    if (policyDecisionSelect) {
                        policyDecisionSelect.addEventListener('change', async function () {
                            const decision = policyDecisionSelect.value;
                            await handlePolicyDecision(uniqueId, decision);
                        });
                    }

                    // Add the event listener for the view policy summary button
                    const viewSummaryBtn = container.querySelector('#view-policy-summary-btn');
                    if (viewSummaryBtn) {
                        viewSummaryBtn.addEventListener('click', function () {
                            if (!uniqueId) {
                                alert('No Unique ID found. Please load an application first.');
                                return;
                            }
                            window.location.href = `/html/Policy_Creation.html?uid=${encodeURIComponent(uniqueId)}&view=summary`;
                        });
                    }

                } catch (err) {
                    console.error('Error rendering plans tab:', err);
                    container.innerHTML = '<p style="color: red;">Failed to load plans. Please try again.</p>';
                }

            };

            /**
             * Handles the final policy decision (Created/Denied).
             * @param {string} uniqueId - The unique ID of the application.
             * @param {string} decision - 'policy_created' or 'policy_denied'.
             */
            async function handlePolicyDecision(uniqueId, decision) {
                const statusEl = document.getElementById('policy-decision-status');
                const selectEl = document.getElementById('policy-decision-select');
                const userRole = localStorage.getItem('userRole');
                if (!uniqueId || !decision) return;

                if (decision === 'policy_created') {
                    // Policy Created option: Navigate to the policy creation page
                    window.location.href = `/html/Policy_Creation.html?uid=${encodeURIComponent(uniqueId)}`;
                    return;
                }

                if (decision === 'policy_denied') {
                    // Policy Denied option: Update status and reload
                    if (!confirm("Are you sure you want to mark this application as Policy Denied? This action cannot be undone.")) {
                        selectEl.value = ''; // Reset dropdown
                        return;
                    }

                    if (selectEl) {
                        selectEl.disabled = true;
                    }
                    statusEl.textContent = 'Processing denial...';
                    statusEl.style.color = 'orange';

                    try {
                        const resp = await fetch('/api/agent/update_status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-User-Id': (localStorage.getItem('loggedInUserId') || 'Unknown')
                            },
                            body: JSON.stringify({
                                unique_id: uniqueId,
                                actor: 'underwriter',
                                status: 'Policy_Denied', // Matches the desired final status
                                comment: 'Application denied at the final policy stage.',
                                application_status: 'Policy_Denied' // Ensure canonical status is set
                            })
                        });

                        if (!resp.ok) {
                            const errorText = await resp.text().catch(() => '');
                            throw new Error(errorText || 'Denial update failed');
                        }

                        statusEl.textContent = 'Policy Denied status set. Reloading...';
                        statusEl.style.color = 'green';

                        // Reload the page to reflect the new status and lock the form
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);

                    } catch (err) {
                        console.error(err);
                        statusEl.textContent = 'Failed to set denial status: ' + (err.message || 'Unknown error');
                        statusEl.style.color = 'red';
                        if (selectEl) selectEl.disabled = false;
                        selectEl.value = ''; // Reset dropdown
                    }
                }
            }
        });
    </script>

    <script>
        // Validation for "Since When (Date)" field when document is uploaded
        document.addEventListener('DOMContentLoaded', function () {
            const previewBtn = document.getElementById('preview-btn');
            if (previewBtn) {
                // Add our validation before any other handlers
                previewBtn.addEventListener('click', function (e) {
                    const sinceDateInput = document.getElementById('policy-since-date');
                    const uploadCheckbox = document.getElementById('upload-policy-doc-checkbox');

                    // Check if document is uploaded and date is empty
                    if (uploadCheckbox && uploadCheckbox.checked && sinceDateInput) {
                        if (!sinceDateInput.value || !sinceDateInput.value.trim()) {
                            e.stopImmediatePropagation();
                            e.preventDefault();
                            alert('Please fill in "Since When (Date)" field. This field is required when a policy document is uploaded.');
                            sinceDateInput.focus();
                            sinceDateInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            return false;
                        }
                    }
                }, true);
            }
        });
    </script>
</body>

</html>